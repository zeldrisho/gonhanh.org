This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: core/src/**/*.rs, platforms/macos/*.swift, scripts/*.sh, .github/workflows/*.yml
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
core/
  src/
    data/
      chars.rs
      constants.rs
      keys.rs
      mod.rs
      vowel.rs
    engine/
      buffer.rs
      mod.rs
      shortcut.rs
      syllable.rs
      transform.rs
      validation.rs
    input/
      mod.rs
      telex.rs
      vni.rs
    updater/
      mod.rs
    lib.rs
    utils.rs
platforms/
  macos/
    AboutView.swift
    App.swift
    AppMetadata.swift
    LaunchAtLogin.swift
    MenuBar.swift
    OnboardingView.swift
    RustBridge.swift
    SettingsView.swift
    UpdateChecker.swift
    UpdateManager.swift
    UpdateView.swift
scripts/
  build-core.sh
  build-macos-swift.sh
  build-macos.sh
  build-windows.sh
  setup.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="core/src/data/chars.rs">
//! Vietnamese Unicode Character System
//!
//! Provides character conversion between base vowels + modifiers + marks
//! and composed Vietnamese Unicode characters.
//!
//! ## Design Principles
//! - Single lookup table for all vowel combinations (12 bases √ó 6 marks = 72)
//! - Uses Rust's built-in `to_uppercase()` for case conversion
//! - No hardcoded case-by-case matching
//!
//! ## Character Components
//! - Base vowel: a, ƒÉ, √¢, e, √™, i, o, √¥, ∆°, u, ∆∞, y
//! - Mark (d·∫•u thanh): none, s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng
//! - Case: lowercase, uppercase

use super::keys;

/// Tone modifiers (d·∫•u ph·ª•) - changes base vowel form
pub mod tone {
    pub const NONE: u8 = 0;
    pub const CIRCUMFLEX: u8 = 1; // ^ (m≈©): a‚Üí√¢, e‚Üí√™, o‚Üí√¥
    pub const HORN: u8 = 2; // ∆°, ∆∞ or breve ƒÉ
}

/// Marks (d·∫•u thanh) - Vietnamese tone marks
pub mod mark {
    pub const NONE: u8 = 0;
    pub const SAC: u8 = 1; // s·∫Øc (√°)
    pub const HUYEN: u8 = 2; // huy·ªÅn (√†)
    pub const HOI: u8 = 3; // h·ªèi (·∫£)
    pub const NGA: u8 = 4; // ng√£ (√£)
    pub const NANG: u8 = 5; // n·∫∑ng (·∫°)
}

/// Vietnamese vowel lookup table
/// Each entry: (base_char, [s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng])
const VOWEL_TABLE: [(char, [char; 5]); 12] = [
    ('a', ['√°', '√†', '·∫£', '√£', '·∫°']),
    ('ƒÉ', ['·∫Ø', '·∫±', '·∫≥', '·∫µ', '·∫∑']),
    ('√¢', ['·∫•', '·∫ß', '·∫©', '·∫´', '·∫≠']),
    ('e', ['√©', '√®', '·∫ª', '·∫Ω', '·∫π']),
    ('√™', ['·∫ø', '·ªÅ', '·ªÉ', '·ªÖ', '·ªá']),
    ('i', ['√≠', '√¨', '·ªâ', 'ƒ©', '·ªã']),
    ('o', ['√≥', '√≤', '·ªè', '√µ', '·ªç']),
    ('√¥', ['·ªë', '·ªì', '·ªï', '·ªó', '·ªô']),
    ('∆°', ['·ªõ', '·ªù', '·ªü', '·ª°', '·ª£']),
    ('u', ['√∫', '√π', '·ªß', '≈©', '·ª•']),
    ('∆∞', ['·ª©', '·ª´', '·ª≠', '·ªØ', '·ª±']),
    ('y', ['√Ω', '·ª≥', '·ª∑', '·ªπ', '·ªµ']),
];

/// Get base character from key + tone modifier
///
/// # Arguments
/// * `key` - Virtual keycode (a, e, i, o, u, y)
/// * `tone` - Tone modifier: 0=none, 1=circumflex(^), 2=horn/breve
///
/// # Returns
/// Base vowel character: a, ƒÉ, √¢, e, √™, i, o, √¥, ∆°, u, ∆∞, y
fn get_base_char(key: u16, t: u8) -> Option<char> {
    match key {
        keys::A => Some(match t {
            tone::CIRCUMFLEX => '√¢',
            tone::HORN => 'ƒÉ', // breve for 'a'
            _ => 'a',
        }),
        keys::E => Some(match t {
            tone::CIRCUMFLEX => '√™',
            _ => 'e',
        }),
        keys::I => Some('i'),
        keys::O => Some(match t {
            tone::CIRCUMFLEX => '√¥',
            tone::HORN => '∆°',
            _ => 'o',
        }),
        keys::U => Some(match t {
            tone::HORN => '∆∞',
            _ => 'u',
        }),
        keys::Y => Some('y'),
        _ => None,
    }
}

/// Apply mark to base vowel character
///
/// Uses lookup table to find the marked variant.
///
/// # Arguments
/// * `base` - Base vowel character (a, ƒÉ, √¢, e, √™, i, o, √¥, ∆°, u, ∆∞, y)
/// * `mark` - Mark: 0=none, 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
fn apply_mark(base: char, m: u8) -> char {
    if m == mark::NONE || m > mark::NANG {
        return base;
    }

    VOWEL_TABLE
        .iter()
        .find(|(b, _)| *b == base)
        .map(|(_, marks)| marks[(m - 1) as usize])
        .unwrap_or(base)
}

/// Convert to uppercase using Rust's Unicode-aware method
///
/// This handles all Vietnamese characters correctly without
/// explicit character mapping.
fn to_upper(ch: char) -> char {
    ch.to_uppercase().next().unwrap_or(ch)
}

/// Convert key + modifiers to Vietnamese character
///
/// # Arguments
/// * `key` - Virtual keycode
/// * `caps` - Uppercase flag
/// * `tone` - Tone modifier: 0=none, 1=circumflex(^), 2=horn/breve
/// * `mark` - Mark: 0=none, 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
pub fn to_char(key: u16, caps: bool, tone: u8, mark: u8) -> Option<char> {
    // Handle D specially (not a vowel but needs conversion)
    if key == keys::D {
        return Some(if caps { 'D' } else { 'd' });
    }

    let base = get_base_char(key, tone)?;
    let marked = apply_mark(base, mark);
    Some(if caps { to_upper(marked) } else { marked })
}

/// Get ƒë/ƒê character
pub fn get_d(caps: bool) -> char {
    if caps {
        'ƒê'
    } else {
        'ƒë'
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_vowels() {
        // Basic vowels without modifiers
        assert_eq!(to_char(keys::A, false, 0, 0), Some('a'));
        assert_eq!(to_char(keys::E, false, 0, 0), Some('e'));
        assert_eq!(to_char(keys::I, false, 0, 0), Some('i'));
        assert_eq!(to_char(keys::O, false, 0, 0), Some('o'));
        assert_eq!(to_char(keys::U, false, 0, 0), Some('u'));
        assert_eq!(to_char(keys::Y, false, 0, 0), Some('y'));
    }

    #[test]
    fn test_tone_modifiers() {
        // Circumflex (^)
        assert_eq!(to_char(keys::A, false, 1, 0), Some('√¢'));
        assert_eq!(to_char(keys::E, false, 1, 0), Some('√™'));
        assert_eq!(to_char(keys::O, false, 1, 0), Some('√¥'));

        // Horn/Breve
        assert_eq!(to_char(keys::A, false, 2, 0), Some('ƒÉ'));
        assert_eq!(to_char(keys::O, false, 2, 0), Some('∆°'));
        assert_eq!(to_char(keys::U, false, 2, 0), Some('∆∞'));
    }

    #[test]
    fn test_marks() {
        // All 5 marks on 'a'
        assert_eq!(to_char(keys::A, false, 0, 1), Some('√°')); // s·∫Øc
        assert_eq!(to_char(keys::A, false, 0, 2), Some('√†')); // huy·ªÅn
        assert_eq!(to_char(keys::A, false, 0, 3), Some('·∫£')); // h·ªèi
        assert_eq!(to_char(keys::A, false, 0, 4), Some('√£')); // ng√£
        assert_eq!(to_char(keys::A, false, 0, 5), Some('·∫°')); // n·∫∑ng
    }

    #[test]
    fn test_combined_tone_and_mark() {
        // √¢ + s·∫Øc = ·∫•
        assert_eq!(to_char(keys::A, false, 1, 1), Some('·∫•'));
        // ∆° + huy·ªÅn = ·ªù
        assert_eq!(to_char(keys::O, false, 2, 2), Some('·ªù'));
        // ∆∞ + n·∫∑ng = ·ª±
        assert_eq!(to_char(keys::U, false, 2, 5), Some('·ª±'));
    }

    #[test]
    fn test_uppercase() {
        assert_eq!(to_char(keys::A, true, 0, 0), Some('A'));
        assert_eq!(to_char(keys::A, true, 0, 1), Some('√Å'));
        assert_eq!(to_char(keys::A, true, 1, 1), Some('·∫§'));
        assert_eq!(to_char(keys::O, true, 2, 2), Some('·ªú'));
        assert_eq!(to_char(keys::U, true, 2, 5), Some('·ª∞'));
    }

    #[test]
    fn test_d() {
        assert_eq!(get_d(false), 'ƒë');
        assert_eq!(get_d(true), 'ƒê');
    }
}
</file>

<file path="core/src/data/keys.rs">
//! macOS virtual keycodes

// Letters
pub const A: u16 = 0;
pub const S: u16 = 1;
pub const D: u16 = 2;
pub const F: u16 = 3;
pub const H: u16 = 4;
pub const G: u16 = 5;
pub const Z: u16 = 6;
pub const X: u16 = 7;
pub const C: u16 = 8;
pub const V: u16 = 9;
pub const B: u16 = 11;
pub const Q: u16 = 12;
pub const W: u16 = 13;
pub const E: u16 = 14;
pub const R: u16 = 15;
pub const Y: u16 = 16;
pub const T: u16 = 17;
pub const O: u16 = 31;
pub const U: u16 = 32;
pub const I: u16 = 34;
pub const P: u16 = 35;
pub const L: u16 = 37;
pub const J: u16 = 38;
pub const K: u16 = 40;
pub const N: u16 = 45;
pub const M: u16 = 46;

// Numbers
pub const N1: u16 = 18;
pub const N2: u16 = 19;
pub const N3: u16 = 20;
pub const N4: u16 = 21;
pub const N5: u16 = 23;
pub const N6: u16 = 22;
pub const N7: u16 = 26;
pub const N8: u16 = 28;
pub const N9: u16 = 25;
pub const N0: u16 = 29;

// Special
pub const SPACE: u16 = 49;
pub const DELETE: u16 = 51;
pub const TAB: u16 = 48;
pub const RETURN: u16 = 36;
pub const ENTER: u16 = 76;
pub const ESC: u16 = 53;
pub const LEFT: u16 = 123;
pub const RIGHT: u16 = 124;
pub const DOWN: u16 = 125;
pub const UP: u16 = 126;

// Punctuation
pub const DOT: u16 = 47;
pub const COMMA: u16 = 43;
pub const SLASH: u16 = 44;
pub const SEMICOLON: u16 = 41;
pub const QUOTE: u16 = 39;
pub const LBRACKET: u16 = 33;
pub const RBRACKET: u16 = 30;
pub const BACKSLASH: u16 = 42;
pub const MINUS: u16 = 27;
pub const EQUAL: u16 = 24;
pub const BACKQUOTE: u16 = 50;

/// Check if key breaks word (space, punctuation, arrows, etc.)
pub fn is_break(key: u16) -> bool {
    matches!(
        key,
        SPACE
            | TAB
            | RETURN
            | ENTER
            | ESC
            | LEFT
            | RIGHT
            | UP
            | DOWN
            | DOT
            | COMMA
            | SLASH
            | SEMICOLON
            | QUOTE
            | LBRACKET
            | RBRACKET
            | BACKSLASH
            | MINUS
            | EQUAL
            | BACKQUOTE
    )
}

/// Check if key is a vowel (a, e, i, o, u, y)
pub fn is_vowel(key: u16) -> bool {
    matches!(key, A | E | I | O | U | Y)
}

/// Check if key is a letter
pub fn is_letter(key: u16) -> bool {
    matches!(
        key,
        A | B
            | C
            | D
            | E
            | F
            | G
            | H
            | I
            | J
            | K
            | L
            | M
            | N
            | O
            | P
            | Q
            | R
            | S
            | T
            | U
            | V
            | W
            | X
            | Y
            | Z
    )
}

/// Check if key is a consonant
pub fn is_consonant(key: u16) -> bool {
    is_letter(key) && !is_vowel(key)
}
</file>

<file path="core/src/data/vowel.rs">
//! Vietnamese Vowel System
//!
//! Implements phonological classification of Vietnamese vowels based on:
//! - docs/vietnamese-language-system.md
//! - https://vi.wikipedia.org/wiki/Quy_t·∫Øc_ƒë·∫∑t_d·∫•u_thanh_c·ªßa_ch·ªØ_Qu·ªëc_ng·ªØ
//!
//! ## Vowel Classification
//!
//! Vietnamese has 12 vowels with 3 modifier types:
//! - Simple: a, e, i, o, u, y
//! - Circumflex (^): √¢, √™, √¥
//! - Horn (m√≥c): ∆°, ∆∞
//! - Breve (trƒÉng): ƒÉ
//!
//! ## Phonological Roles
//!
//! In Vietnamese syllable structure (C)(G)V(C):
//! - **Medial (√¢m ƒë·ªám)**: o, u when followed by main vowel (oa, oe, uy, ua, u√™)
//! - **Main (√¢m ch√≠nh)**: The primary vowel carrying tone
//! - **Glide (b√°n nguy√™n √¢m)**: i/y, u/o at syllable end (ai, ao, iu, oi)

use super::keys;

/// Vowel modifier type (d·∫•u ph·ª•)
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Modifier {
    None = 0,       // a, e, i, o, u, y
    Circumflex = 1, // √¢, √™, √¥ (^)
    Horn = 2,       // ∆°, ∆∞ (m√≥c) / ƒÉ (trƒÉng)
}

/// Phonological role in syllable
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Role {
    Main,   // Primary vowel (carries tone)
    Medial, // Glide before main vowel (o in oa, u in uy)
    Final,  // Glide at syllable end (i in ai, u in au)
}

/// Vowel information
#[derive(Clone, Copy, Debug)]
pub struct Vowel {
    pub key: u16,
    pub modifier: Modifier,
    pub pos: usize,
}

impl Vowel {
    pub fn new(key: u16, modifier: Modifier, pos: usize) -> Self {
        Self { key, modifier, pos }
    }

    /// Check if this vowel has a diacritic modifier (^, ∆°, ∆∞, ƒÉ)
    pub fn has_diacritic(&self) -> bool {
        self.modifier != Modifier::None
    }
}

/// Vietnamese vowel phonology analyzer
pub struct Phonology;

impl Phonology {
    /// Find the position where tone mark should be placed
    ///
    /// ## Vietnamese Tone Placement Rules
    ///
    /// Based on docs/vietnamese-language-system.md section 7:
    ///
    /// 1. **Single vowel**: Mark directly on it
    ///
    /// 2. **Two vowels with final consonant**: Mark on 2nd vowel
    ///    - to√°n, ho√†n, ti·∫øn, mu·ªën, bi·ªÉn
    ///
    /// 3. **Two vowels open syllable**:
    ///    - Medial + Main (oa, oe, uy, qua, u√™): Mark on 2nd (main)
    ///    - Main + Glide (ai, ao, au, oi, ui): Mark on 1st (main)
    ///    - Compound (∆∞∆°, u√¥, i√™): Mark on 2nd (main has diacritic)
    ///    - ∆∞a pattern: Mark on 1st (∆∞ has diacritic, a is simple)
    ///    - ua without q: Mark on 1st (u is main, e.g., m√πa)
    ///
    /// 4. **Three+ vowels**: Mark on middle vowel
    ///    - ∆∞∆°i, oai, u√¥i: Mark on middle
    ///
    /// 5. **Diacritic priority**: When vowel has diacritic (ƒÉ, √¢, √™, √¥, ∆°, ∆∞),
    ///    it often receives the mark
    ///
    /// ## Parameters
    /// - `has_qu_initial`: true if 'q' precedes 'u' (e.g., "qua" vs "mua")
    pub fn find_tone_position(
        vowels: &[Vowel],
        has_final_consonant: bool,
        modern: bool,
        has_qu_initial: bool,
    ) -> usize {
        let n = vowels.len();
        if n == 0 {
            return 0;
        }
        if n == 1 {
            return vowels[0].pos;
        }

        // Two vowels
        if n == 2 {
            let v1 = &vowels[0];
            let v2 = &vowels[1];

            // With final consonant: always mark on 2nd vowel
            if has_final_consonant {
                return v2.pos;
            }

            // ∆∞a pattern: ∆∞ has diacritic, a doesn't ‚Üí mark on ∆∞
            // This must be checked BEFORE compound vowels because ∆∞a is not ∆∞∆°
            // General rule: if 1st has diacritic and 2nd doesn't, mark on 1st
            // Note: when 1st has diacritic, it's no longer a simple medial pair
            // e.g., "ua" (qua) is medial pair, but "∆∞a" (s·ª©a) is not
            if v1.has_diacritic() && !v2.has_diacritic() {
                return v1.pos;
            }

            // Compound vowels ∆∞∆°, u√¥, i√™: mark on 2nd (has diacritic)
            if Self::is_compound_vowel(v1.key, v2.key) {
                return v2.pos;
            }

            // 2nd has diacritic ‚Üí mark on 2nd
            if v2.has_diacritic() {
                return v2.pos;
            }

            // Medial pairs (oa, oe, uy, u√™, and ua with q): mark on 2nd (main vowel)
            if Self::is_medial_pair(v1.key, v2.key, has_qu_initial) {
                return if modern { v2.pos } else { v1.pos };
            }

            // ua without q (mua): u is main vowel, a is glide ‚Üí mark on u
            if v1.key == keys::U && v2.key == keys::A && !has_qu_initial {
                return v1.pos;
            }

            // Main + glide (ai, ao, au, oi, ui): mark on 1st (main vowel)
            if Self::is_main_glide_pair(v1.key, v2.key) {
                return v1.pos;
            }

            // Default: mark on 2nd
            return v2.pos;
        }

        // Three+ vowels
        if n == 3 {
            let k0 = vowels[0].key;
            let k1 = vowels[1].key;
            let k2 = vowels[2].key;

            // Priority 1: Middle vowel with diacritic
            // ∆∞∆°i (m∆∞·ªùi): ∆∞ and ∆° both have diacritic, mark on ∆° (middle)
            if vowels[1].has_diacritic() {
                return vowels[1].pos;
            }

            // Priority 2: Last vowel with diacritic (and middle doesn't)
            // uy√™ (khuy√™n): mark on √™ (has diacritic)
            if vowels[2].has_diacritic() {
                return vowels[2].pos;
            }

            // Priority 3: ∆∞∆°i, u√¥i patterns: mark on middle
            if k0 == keys::U && k1 == keys::O {
                return vowels[1].pos;
            }

            // Priority 4: oai, oay patterns: mark on middle (a)
            if k0 == keys::O && k1 == keys::A {
                return vowels[1].pos;
            }

            // Priority 5: uy√™ pattern (no diacritic on √™ yet): mark on √™ (last)
            if k0 == keys::U && k1 == keys::Y && k2 == keys::E {
                return vowels[2].pos;
            }
        }

        // For 4+ vowels: find middle vowel with diacritic first
        let mid = n / 2;
        if vowels[mid].has_diacritic() {
            return vowels[mid].pos;
        }

        // Then any vowel with diacritic
        for v in vowels {
            if v.has_diacritic() {
                return v.pos;
            }
        }

        // Default: middle vowel
        vowels[mid].pos
    }

    /// Determine the role of each vowel in a syllable
    #[allow(dead_code)]
    pub fn classify_roles(
        vowels: &[Vowel],
        has_final_consonant: bool,
        has_qu_initial: bool,
    ) -> Vec<(usize, Role)> {
        let n = vowels.len();
        if n == 0 {
            return vec![];
        }
        if n == 1 {
            return vec![(vowels[0].pos, Role::Main)];
        }

        let mut roles = vec![Role::Main; n];

        if n == 2 {
            let (k1, k2) = (vowels[0].key, vowels[1].key);

            if Self::is_medial_pair(k1, k2, has_qu_initial)
                || Self::is_compound_vowel(k1, k2)
                || has_final_consonant
            {
                roles[0] = Role::Medial;
                roles[1] = Role::Main;
            } else if Self::is_main_glide_pair(k1, k2)
                || (vowels[0].has_diacritic() && !vowels[1].has_diacritic())
            {
                // ∆∞a pattern: ∆∞ is main
                roles[0] = Role::Main;
                roles[1] = Role::Final;
            }
        } else {
            // Three+ vowels
            roles[0] = Role::Medial;
            if !has_final_consonant {
                roles[n - 1] = Role::Final;
            }

            // Find main vowel
            let main_idx = n / 2;
            roles[main_idx] = Role::Main;
        }

        vowels.iter().zip(roles).map(|(v, r)| (v.pos, r)).collect()
    }

    /// Check if v1+v2 forms a medial+main pair (√¢m ƒë·ªám + √¢m ch√≠nh)
    ///
    /// Medial pairs: oa, oe, u√™, uy, and ua (only when preceded by 'q')
    /// These are when the first vowel acts as a glide before the main vowel
    ///
    /// Note: "ua" is special:
    /// - "qua" ‚Üí qu√° (u is medial, mark on a)
    /// - "mua" ‚Üí m√πa (u is main vowel, mark on u)
    fn is_medial_pair(v1: u16, v2: u16, has_qu_initial: bool) -> bool {
        // ua is only medial when preceded by 'q'
        if v1 == keys::U && v2 == keys::A {
            return has_qu_initial;
        }

        matches!(
            (v1, v2),
            (keys::O, keys::A) | // oa
            (keys::O, keys::E) | // oe
            (keys::U, keys::E) | // u√™
            (keys::U, keys::Y) // uy
        )
    }

    /// Check if v1+v2 forms a main+glide pair (√¢m ch√≠nh + b√°n nguy√™n √¢m)
    ///
    /// Final glide pairs: ai, ay, ao, au, oi, √¥i, ∆°i, ui, ∆∞i, √™u, iu, etc.
    fn is_main_glide_pair(v1: u16, v2: u16) -> bool {
        // Second vowel must be a glide (i, y, o, u)
        let is_glide = matches!(v2, keys::I | keys::Y | keys::O | keys::U);
        if !is_glide {
            return false;
        }

        // Not a medial or compound pattern
        // Note: for is_main_glide_pair, we pass false for has_qu_initial since
        // this check is about the pair pattern, not the specific context
        !Self::is_medial_pair(v1, v2, false) && !Self::is_compound_vowel(v1, v2)
    }

    /// Check if v1+v2 forms a compound vowel (∆∞∆°, u√¥, i√™)
    ///
    /// These are diphthongs where second vowel (with diacritic) carries the tone
    fn is_compound_vowel(v1: u16, v2: u16) -> bool {
        matches!(
            (v1, v2),
            (keys::U, keys::O) | // ∆∞∆°, u√¥
            (keys::I, keys::E) // i√™
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn v(key: u16, modifier: Modifier, pos: usize) -> Vowel {
        Vowel::new(key, modifier, pos)
    }

    #[test]
    fn test_single_vowel() {
        let vowels = vec![v(keys::A, Modifier::None, 0)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );
    }

    #[test]
    fn test_medial_pairs() {
        // oa ‚Üí mark on a (pos 1)
        let vowels = vec![v(keys::O, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );

        // uy ‚Üí mark on y (pos 1)
        let vowels = vec![v(keys::U, Modifier::None, 0), v(keys::Y, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );
    }

    #[test]
    fn test_ua_patterns() {
        // ua without q (mua) ‚Üí mark on u (pos 0)
        let vowels = vec![v(keys::U, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );

        // ua with q (qua) ‚Üí mark on a (pos 1)
        let vowels = vec![v(keys::U, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(Phonology::find_tone_position(&vowels, false, true, true), 1);
    }

    #[test]
    fn test_main_glide_pairs() {
        // ai ‚Üí mark on a (pos 0)
        let vowels = vec![v(keys::A, Modifier::None, 0), v(keys::I, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );

        // ao ‚Üí mark on a (pos 0)
        let vowels = vec![v(keys::A, Modifier::None, 0), v(keys::O, Modifier::None, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );
    }

    #[test]
    fn test_with_final_consonant() {
        // oan ‚Üí mark on a (pos 1)
        let vowels = vec![v(keys::O, Modifier::None, 0), v(keys::A, Modifier::None, 1)];
        assert_eq!(Phonology::find_tone_position(&vowels, true, true, false), 1);
    }

    #[test]
    fn test_compound_vowels() {
        // ∆∞∆° ‚Üí mark on ∆° (pos 1)
        let vowels = vec![v(keys::U, Modifier::Horn, 0), v(keys::O, Modifier::Horn, 1)];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );

        // i√™ ‚Üí mark on √™ (pos 1)
        let vowels = vec![
            v(keys::I, Modifier::None, 0),
            v(keys::E, Modifier::Circumflex, 1),
        ];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );
    }

    #[test]
    fn test_three_vowels() {
        // ∆∞∆°i ‚Üí mark on ∆° (pos 1, middle with diacritic)
        let vowels = vec![
            v(keys::U, Modifier::Horn, 0),
            v(keys::O, Modifier::Horn, 1),
            v(keys::I, Modifier::None, 2),
        ];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );

        // oai ‚Üí mark on a (pos 1, middle)
        let vowels = vec![
            v(keys::O, Modifier::None, 0),
            v(keys::A, Modifier::None, 1),
            v(keys::I, Modifier::None, 2),
        ];
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            1
        );
    }

    #[test]
    fn test_diacritic_priority() {
        // ∆∞a ‚Üí mark on ∆∞ (pos 0, has diacritic)
        let vowels = vec![v(keys::U, Modifier::Horn, 0), v(keys::A, Modifier::None, 1)];
        // ∆∞a is NOT a compound vowel (compound is ∆∞∆°, not ∆∞a)
        // ∆∞ has diacritic, a doesn't ‚Üí mark on ∆∞
        assert_eq!(
            Phonology::find_tone_position(&vowels, false, true, false),
            0
        );
    }
}
</file>

<file path="platforms/macos/SettingsView.swift">
import SwiftUI

// SettingsView removed - settings are managed via menu bar
// This file kept for Xcode project compatibility

struct SettingsView: View {
    var body: some View {
        EmptyView()
    }
}
</file>

<file path="scripts/build-core.sh">
#!/bin/bash
set -e

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

echo "ü¶Ä Building Rust core..."

cd "$(dirname "$0")/../core"

# Build for macOS (universal binary)
echo "Building for aarch64-apple-darwin..."
cargo build --release --target aarch64-apple-darwin

echo "Building for x86_64-apple-darwin..."
cargo build --release --target x86_64-apple-darwin

# Create universal binary
echo "Creating universal binary..."
lipo -create \
    target/aarch64-apple-darwin/release/libgonhanh_core.a \
    target/x86_64-apple-darwin/release/libgonhanh_core.a \
    -output ../platforms/macos/libgonhanh_core.a

echo "‚úÖ Rust core built successfully!"
echo "üì¶ Output: platforms/macos/libgonhanh_core.a"
</file>

<file path="scripts/build-macos-swift.sh">
#!/bin/bash
set -e

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

echo "üçé Building macOS app with swiftc..."

# Build core first
./scripts/build-core.sh

cd "$(dirname "$0")/../platforms/macos"

# Create build directory
mkdir -p build/Release

# Compile Swift files
echo "Compiling Swift sources..."
swiftc \
    -o build/Release/GoNhanh \
    -sdk $(xcrun --show-sdk-path) \
    -target arm64-apple-macos13.0 \
    -F /System/Library/Frameworks \
    -framework Foundation \
    -framework AppKit \
    -framework SwiftUI \
    -L . \
    -lgonhanh_core \
    -Xlinker -rpath -Xlinker @executable_path \
    App.swift MenuBar.swift SettingsView.swift RustBridge.swift

echo "‚úÖ macOS app built successfully!"
echo "üì¶ Binary: platforms/macos/build/Release/GoNhanh"
echo ""
echo "To create .app bundle, run: make bundle"
</file>

<file path="scripts/setup.sh">
#!/bin/bash
set -e

echo "üöÄ Setting up GoNhanh development environment..."

# Source rustup if available
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

# Check Rust
if ! command -v cargo &> /dev/null; then
    echo "‚ùå Rust not found. Please install: https://rustup.rs"
    exit 1
fi
echo "‚úÖ Rust found: $(rustc --version)"
echo "üìç Cargo location: $(which cargo)"

# Install Rust targets for macOS
echo "üì¶ Installing Rust targets..."
rustup target add aarch64-apple-darwin
rustup target add x86_64-apple-darwin

# Check Xcode (macOS only)
if [[ "$OSTYPE" == "darwin"* ]]; then
    if ! command -v xcodebuild &> /dev/null; then
        echo "‚ö†Ô∏è  Xcode not found. Please install from App Store."
    else
        echo "‚úÖ Xcode found: $(xcodebuild -version | head -n 1)"
    fi
fi

# Make scripts executable
chmod +x scripts/*.sh

echo ""
echo "‚úÖ Setup complete!"
echo ""
echo "Next steps:"
echo "  1. Build Rust core:  ./scripts/build-core.sh"
echo "  2. Create Xcode project in platforms/macos/"
echo "  3. Build macOS app:  ./scripts/build-macos.sh"
echo ""
echo "Documentation: docs/development.md"
</file>

<file path="core/src/data/mod.rs">
//! Vietnamese Language Data Modules
//!
//! This module contains all linguistic data for Vietnamese input:
//! - `keys`: Virtual keycode definitions (platform-specific)
//! - `chars`: Unicode character conversion (includes tone/mark constants)
//! - `vowel`: Vietnamese vowel phonology system

pub mod chars;
pub mod constants;
pub mod keys;
pub mod vowel;

pub use chars::{get_d, mark, to_char, tone};
pub use constants::*;
pub use keys::{is_break, is_letter, is_vowel};
pub use vowel::{Modifier, Phonology, Role, Vowel};
</file>

<file path="core/src/updater/mod.rs">
//! Auto-update module for GoNhanh
//!
//! Provides version comparison utilities that can be used across all platforms.
//! HTTP calls are handled by the platform layer (Swift/C#/GTK) for flexibility.

/// Semantic version representation
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Version {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
}

impl Version {
    /// Parse a version string like "1.2.3" or "v1.2.3"
    pub fn parse(s: &str) -> Option<Version> {
        let s = s.trim().strip_prefix('v').unwrap_or(s);
        let parts: Vec<&str> = s.split('.').collect();

        if parts.len() < 2 {
            return None;
        }

        let major = parts[0].parse().ok()?;
        let minor = parts[1].parse().ok()?;
        let patch = parts.get(2).and_then(|p| p.parse().ok()).unwrap_or(0);

        Some(Version {
            major,
            minor,
            patch,
        })
    }

    /// Compare two versions
    /// Returns: -1 if self < other, 0 if equal, 1 if self > other
    pub fn compare(&self, other: &Version) -> i32 {
        if self.major != other.major {
            return if self.major < other.major { -1 } else { 1 };
        }
        if self.minor != other.minor {
            return if self.minor < other.minor { -1 } else { 1 };
        }
        if self.patch != other.patch {
            return if self.patch < other.patch { -1 } else { 1 };
        }
        0
    }

    /// Check if update is available (other > self)
    pub fn has_update(&self, other: &Version) -> bool {
        self.compare(other) < 0
    }
}

impl std::fmt::Display for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}.{}.{}", self.major, self.minor, self.patch)
    }
}

// ============================================================
// FFI Interface for Version Comparison
// ============================================================

/// Compare two version strings
/// Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2, -99 if parse error
///
/// # Safety
/// Callers must ensure v1 and v2 are valid null-terminated C strings or null pointers.
#[no_mangle]
#[allow(clippy::not_unsafe_ptr_arg_deref)]
pub extern "C" fn version_compare(v1: *const i8, v2: *const i8) -> i32 {
    let v1_str = unsafe {
        if v1.is_null() {
            return -99;
        }
        match std::ffi::CStr::from_ptr(v1).to_str() {
            Ok(s) => s,
            Err(_) => return -99,
        }
    };

    let v2_str = unsafe {
        if v2.is_null() {
            return -99;
        }
        match std::ffi::CStr::from_ptr(v2).to_str() {
            Ok(s) => s,
            Err(_) => return -99,
        }
    };

    let ver1 = match Version::parse(v1_str) {
        Some(v) => v,
        None => return -99,
    };

    let ver2 = match Version::parse(v2_str) {
        Some(v) => v,
        None => return -99,
    };

    ver1.compare(&ver2)
}

/// Check if an update is available
/// Returns: 1 if v2 > v1 (update available), 0 if not, -99 if parse error
#[no_mangle]
pub extern "C" fn version_has_update(current: *const i8, latest: *const i8) -> i32 {
    let result = version_compare(current, latest);
    if result == -99 {
        return -99;
    }
    if result < 0 {
        1
    } else {
        0
    }
}

// ============================================================
// Tests
// ============================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_version_parse() {
        assert_eq!(
            Version::parse("1.2.3"),
            Some(Version {
                major: 1,
                minor: 2,
                patch: 3
            })
        );
        assert_eq!(
            Version::parse("v1.2.3"),
            Some(Version {
                major: 1,
                minor: 2,
                patch: 3
            })
        );
        assert_eq!(
            Version::parse("1.0"),
            Some(Version {
                major: 1,
                minor: 0,
                patch: 0
            })
        );
        assert_eq!(Version::parse("invalid"), None);
    }

    #[test]
    fn test_version_compare() {
        let v1 = Version::parse("1.0.0").unwrap();
        let v2 = Version::parse("1.0.1").unwrap();
        let v3 = Version::parse("1.1.0").unwrap();
        let v4 = Version::parse("2.0.0").unwrap();

        assert_eq!(v1.compare(&v1), 0);
        assert_eq!(v1.compare(&v2), -1);
        assert_eq!(v2.compare(&v1), 1);
        assert_eq!(v1.compare(&v3), -1);
        assert_eq!(v1.compare(&v4), -1);
    }

    #[test]
    fn test_has_update() {
        let current = Version::parse("1.0.9").unwrap();
        let latest = Version::parse("1.0.10").unwrap();
        assert!(current.has_update(&latest));

        let same = Version::parse("1.0.9").unwrap();
        assert!(!current.has_update(&same));
    }

    #[test]
    fn test_ffi_version_compare() {
        use std::ffi::CString;

        let v1 = CString::new("1.0.0").unwrap();
        let v2 = CString::new("1.0.1").unwrap();

        assert_eq!(version_compare(v1.as_ptr(), v2.as_ptr()), -1);
        assert_eq!(version_compare(v2.as_ptr(), v1.as_ptr()), 1);
        assert_eq!(version_compare(v1.as_ptr(), v1.as_ptr()), 0);
    }

    #[test]
    fn test_ffi_has_update() {
        use std::ffi::CString;

        let current = CString::new("1.0.9").unwrap();
        let latest = CString::new("1.0.10").unwrap();

        assert_eq!(version_has_update(current.as_ptr(), latest.as_ptr()), 1);
        assert_eq!(version_has_update(latest.as_ptr(), current.as_ptr()), 0);
    }
}
</file>

<file path="platforms/macos/LaunchAtLogin.swift">
import Foundation
import ServiceManagement

// MARK: - Launch at Login Manager

/// Protocol for launch at login functionality (enables testing)
protocol LaunchAtLoginProtocol {
    var isEnabled: Bool { get }
    func enable() throws
    func disable() throws
}

/// Manages app's launch at login state using SMAppService
class LaunchAtLoginManager: LaunchAtLoginProtocol {
    static let shared = LaunchAtLoginManager()

    private init() {}

    /// Check if launch at login is currently enabled
    var isEnabled: Bool {
        if #available(macOS 13.0, *) {
            return SMAppService.mainApp.status == .enabled
        }
        return false
    }

    /// Enable launch at login
    func enable() throws {
        if #available(macOS 13.0, *) {
            if SMAppService.mainApp.status != .enabled {
                try SMAppService.mainApp.register()
                debugLog("[LaunchAtLogin] Enabled successfully")
            }
        } else {
            debugLog("[LaunchAtLogin] Requires macOS 13.0+")
        }
    }

    /// Disable launch at login
    func disable() throws {
        if #available(macOS 13.0, *) {
            if SMAppService.mainApp.status == .enabled {
                try SMAppService.mainApp.unregister()
                debugLog("[LaunchAtLogin] Disabled successfully")
            }
        }
    }

    /// Get current status as string (for debugging)
    var statusDescription: String {
        if #available(macOS 13.0, *) {
            switch SMAppService.mainApp.status {
            case .enabled:
                return "enabled"
            case .notFound:
                return "notFound"
            case .notRegistered:
                return "notRegistered"
            case .requiresApproval:
                return "requiresApproval"
            @unknown default:
                return "unknown"
            }
        }
        return "unsupported"
    }
}

// MARK: - Mock for Testing

/// Mock implementation for unit testing
class MockLaunchAtLoginManager: LaunchAtLoginProtocol {
    private(set) var isEnabled: Bool = false
    private(set) var enableCallCount = 0
    private(set) var disableCallCount = 0
    var shouldThrowOnEnable = false
    var shouldThrowOnDisable = false

    func enable() throws {
        enableCallCount += 1
        if shouldThrowOnEnable {
            throw LaunchAtLoginError.registrationFailed
        }
        isEnabled = true
    }

    func disable() throws {
        disableCallCount += 1
        if shouldThrowOnDisable {
            throw LaunchAtLoginError.unregistrationFailed
        }
        isEnabled = false
    }

    func reset() {
        isEnabled = false
        enableCallCount = 0
        disableCallCount = 0
        shouldThrowOnEnable = false
        shouldThrowOnDisable = false
    }
}

enum LaunchAtLoginError: Error {
    case registrationFailed
    case unregistrationFailed
}

// MARK: - Settings Integration

extension LaunchAtLoginManager {
    /// Key for UserDefaults (backup/fallback)
    static let userDefaultsKey = "launchAtLoginEnabled"

    /// Sync state with UserDefaults
    func syncWithUserDefaults() {
        UserDefaults.standard.set(isEnabled, forKey: Self.userDefaultsKey)
    }

    /// Get cached state from UserDefaults (for UI before SMAppService check)
    var cachedState: Bool {
        UserDefaults.standard.bool(forKey: Self.userDefaultsKey)
    }
}
</file>

<file path="platforms/macos/UpdateChecker.swift">
import Foundation

// MARK: - FFI for Version Comparison

@_silgen_name("version_compare")
func version_compare(_ v1: UnsafePointer<CChar>?, _ v2: UnsafePointer<CChar>?) -> Int32

@_silgen_name("version_has_update")
func version_has_update(_ current: UnsafePointer<CChar>?, _ latest: UnsafePointer<CChar>?) -> Int32

// MARK: - Update Info

struct UpdateInfo {
    let version: String
    let downloadURL: URL
    let releaseNotes: String
    let publishedAt: Date?
}

// MARK: - Update Check Result

enum UpdateCheckResult {
    case available(UpdateInfo)
    case upToDate
    case error(String)
}

// MARK: - Update Checker

class UpdateChecker {
    static let shared = UpdateChecker()

    private let githubAPIURL = "https://api.github.com/repos/khaphanspace/gonhanh.org/releases/latest"
    private let downloadBaseURL = "https://github.com/khaphanspace/gonhanh.org/releases/latest/download"

    private init() {}

    /// Check for updates asynchronously
    func checkForUpdates(completion: @escaping (UpdateCheckResult) -> Void) {
        guard let url = URL(string: githubAPIURL) else {
            completion(.error("Invalid API URL"))
            return
        }

        var request = URLRequest(url: url)
        request.setValue("application/vnd.github.v3+json", forHTTPHeaderField: "Accept")
        request.timeoutInterval = 10

        let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
            if let error = error {
                DispatchQueue.main.async {
                    completion(.error("Network error: \(error.localizedDescription)"))
                }
                return
            }

            guard let httpResponse = response as? HTTPURLResponse else {
                DispatchQueue.main.async {
                    completion(.error("Invalid response"))
                }
                return
            }

            guard httpResponse.statusCode == 200 else {
                DispatchQueue.main.async {
                    completion(.error("Server error: \(httpResponse.statusCode)"))
                }
                return
            }

            guard let data = data else {
                DispatchQueue.main.async {
                    completion(.error("No data received"))
                }
                return
            }

            self?.parseResponse(data: data, completion: completion)
        }

        task.resume()
    }

    private func parseResponse(data: Data, completion: @escaping (UpdateCheckResult) -> Void) {
        do {
            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                DispatchQueue.main.async {
                    completion(.error("Invalid JSON format"))
                }
                return
            }

            // Extract version from tag_name (e.g., "v1.0.10" -> "1.0.10")
            guard let tagName = json["tag_name"] as? String else {
                DispatchQueue.main.async {
                    completion(.error("Missing version tag"))
                }
                return
            }

            let latestVersion = tagName.hasPrefix("v") ? String(tagName.dropFirst()) : tagName
            let currentVersion = AppMetadata.version

            // Use Rust core for version comparison
            let hasUpdate = currentVersion.withCString { currentPtr in
                latestVersion.withCString { latestPtr in
                    version_has_update(currentPtr, latestPtr)
                }
            }

            if hasUpdate == 1 {
                // Parse additional info
                let releaseNotes = json["body"] as? String ?? ""
                let htmlURL = json["html_url"] as? String ?? ""

                // Find DMG download URL from assets
                var downloadURL: URL?
                if let assets = json["assets"] as? [[String: Any]] {
                    for asset in assets {
                        if let name = asset["name"] as? String,
                           name.lowercased().hasSuffix(".dmg"),
                           let urlString = asset["browser_download_url"] as? String,
                           let url = URL(string: urlString) {
                            downloadURL = url
                            break
                        }
                    }
                }

                // Fallback to default download URL
                let finalDownloadURL = downloadURL ?? URL(string: "\(downloadBaseURL)/GoNhanh.dmg")!

                // Parse published date
                var publishedAt: Date?
                if let publishedString = json["published_at"] as? String {
                    let formatter = ISO8601DateFormatter()
                    publishedAt = formatter.date(from: publishedString)
                }

                let updateInfo = UpdateInfo(
                    version: latestVersion,
                    downloadURL: finalDownloadURL,
                    releaseNotes: releaseNotes,
                    publishedAt: publishedAt
                )

                DispatchQueue.main.async {
                    completion(.available(updateInfo))
                }
            } else {
                DispatchQueue.main.async {
                    completion(.upToDate)
                }
            }

        } catch {
            DispatchQueue.main.async {
                completion(.error("JSON parse error: \(error.localizedDescription)"))
            }
        }
    }

    /// Compare two version strings using Rust core
    /// Returns: -1 if v1 < v2, 0 if equal, 1 if v1 > v2
    func compareVersions(_ v1: String, _ v2: String) -> Int {
        return v1.withCString { v1Ptr in
            v2.withCString { v2Ptr in
                Int(version_compare(v1Ptr, v2Ptr))
            }
        }
    }
}
</file>

<file path="platforms/macos/UpdateView.swift">
import SwiftUI

struct UpdateView: View {
    @Environment(\.colorScheme) private var colorScheme
    @ObservedObject var updateManager = UpdateManager.shared

    var body: some View {
        VStack(spacing: 0) {
            content
            Divider()
            footer
        }
        .frame(width: 360)
        .background(colorScheme == .dark ? Color.black.opacity(0.2) : Color.white)
    }

    @ViewBuilder
    private var content: some View {
        switch updateManager.state {
        case .idle:
            idleView
        case .checking:
            checkingView
        case .upToDate:
            upToDateView
        case .available(let info):
            availableView(info)
        case .downloading(let progress):
            downloadingView(progress)
        case .readyToInstall:
            readyView
        case .error(let message):
            errorView(message)
        }
    }

    // MARK: - States

    private var idleView: some View {
        VStack(spacing: 16) {
            Spacer()

            Image(nsImage: AppMetadata.logo)
                .resizable()
                .frame(width: 64, height: 64)
                .shadow(color: .black.opacity(0.1), radius: 4, y: 2)

            Text(AppMetadata.name)
                .font(.system(size: 20, weight: .bold, design: .rounded))

            versionBadge(label: "Phi√™n b·∫£n", value: AppMetadata.version)

            if let lastCheck = updateManager.lastCheckDate {
                Text("Ki·ªÉm tra l·∫ßn cu·ªëi: \(lastCheck.formatted(.relative(presentation: .named)))")
                    .font(.caption)
                    .foregroundStyle(.tertiary)
            }

            Spacer()

            Button("Ki·ªÉm tra c·∫≠p nh·∫≠t") {
                updateManager.checkForUpdatesManually()
            }
            .buttonStyle(.borderedProminent)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var checkingView: some View {
        VStack(spacing: 16) {
            Spacer()

            ProgressView()
                .scaleEffect(1.5)

            Text("ƒêang ki·ªÉm tra...")
                .font(.system(size: 18, weight: .medium, design: .rounded))

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var upToDateView: some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "checkmark", color: .green)

            Text("ƒê√£ c·∫≠p nh·∫≠t m·ªõi nh·∫•t")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            versionBadge(label: "Phi√™n b·∫£n", value: AppMetadata.version)

            Spacer()

            Button("Ki·ªÉm tra l·∫°i") {
                updateManager.checkForUpdatesManually()
            }

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private func availableView(_ info: UpdateInfo) -> some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "arrow.down", color: .blue)

            Text("C√≥ phi√™n b·∫£n m·ªõi")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            // Version comparison
            HStack(spacing: 16) {
                versionBadge(label: "Hi·ªán t·∫°i", value: AppMetadata.version)

                Image(systemName: "arrow.right")
                    .font(.caption)
                    .foregroundStyle(.tertiary)

                versionBadge(label: "M·ªõi", value: info.version, highlight: true)
            }

            // Release notes
            if !info.releaseNotes.isEmpty {
                ScrollView {
                    Text(info.releaseNotes)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                        .frame(maxWidth: .infinity, alignment: .leading)
                }
                .frame(maxHeight: 80)
                .padding(10)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(colorScheme == .dark ? Color.white.opacity(0.06) : Color.black.opacity(0.03))
                )
            }

            Spacer()

            // Actions
            VStack(spacing: 10) {
                Button("T·∫£i v·ªÅ") {
                    updateManager.downloadUpdate(info)
                }
                .buttonStyle(.borderedProminent)

                HStack(spacing: 20) {
                    Button("ƒê·ªÉ sau") {
                        updateManager.state = .idle
                    }
                    .foregroundStyle(.secondary)

                    Button("B·ªè qua") {
                        updateManager.skipVersion(info.version)
                    }
                    .foregroundStyle(.tertiary)
                }
                .font(.callout)
            }

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private func downloadingView(_ progress: Double) -> some View {
        VStack(spacing: 16) {
            Spacer()

            ZStack {
                Circle()
                    .stroke(colorScheme == .dark ? Color.white.opacity(0.1) : Color.black.opacity(0.08), lineWidth: 4)
                    .frame(width: 64, height: 64)

                Circle()
                    .trim(from: 0, to: progress)
                    .stroke(Color.accentColor, style: StrokeStyle(lineWidth: 4, lineCap: .round))
                    .frame(width: 64, height: 64)
                    .rotationEffect(.degrees(-90))

                Text("\(Int(progress * 100))%")
                    .font(.system(size: 14, weight: .bold, design: .rounded))
            }

            Text("ƒêang t·∫£i v·ªÅ...")
                .font(.system(size: 18, weight: .medium, design: .rounded))

            Spacer()

            Button("H·ªßy") {
                updateManager.cancelDownload()
            }
            .foregroundStyle(.secondary)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private var readyView: some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "checkmark", color: .green)

            Text("S·∫µn s√†ng c√†i ƒë·∫∑t")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            Text("·ª®ng d·ª•ng s·∫Ω tho√°t ƒë·ªÉ c√†i ƒë·∫∑t")
                .font(.callout)
                .foregroundStyle(.secondary)

            Spacer()

            Button("C√†i ƒë·∫∑t ngay") {
                updateManager.installUpdate()
            }
            .buttonStyle(.borderedProminent)

            Button("ƒê·ªÉ sau") {
                updateManager.state = .idle
            }
            .font(.callout)
            .foregroundStyle(.secondary)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    private func errorView(_ message: String) -> some View {
        VStack(spacing: 16) {
            Spacer()

            iconCircle(icon: "exclamationmark", color: .orange)

            Text("L·ªói k·∫øt n·ªëi")
                .font(.system(size: 18, weight: .bold, design: .rounded))

            Text(message)
                .font(.callout)
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)

            Spacer()

            Button("Th·ª≠ l·∫°i") {
                updateManager.checkForUpdatesManually()
            }
            .buttonStyle(.borderedProminent)

            Spacer()
        }
        .padding(.horizontal, 28)
        .padding(.vertical, 24)
    }

    // MARK: - Components

    private func iconCircle(icon: String, color: Color) -> some View {
        ZStack {
            Circle()
                .fill(color.opacity(colorScheme == .dark ? 0.2 : 0.1))
                .frame(width: 64, height: 64)

            Image(systemName: icon)
                .font(.system(size: 28, weight: .medium))
                .foregroundStyle(color)
        }
    }

    private func versionBadge(label: String, value: String, highlight: Bool = false) -> some View {
        HStack(spacing: 4) {
            Text(label)
                .font(.caption2)
                .foregroundStyle(.tertiary)
            Text(value)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundStyle(highlight ? .green : .secondary)
        }
        .padding(.horizontal, 10)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(colorScheme == .dark ? Color.white.opacity(0.08) : Color.black.opacity(0.04))
        )
    }

    // MARK: - Footer

    private var footer: some View {
        Link(destination: URL(string: AppMetadata.repository + "/releases")!) {
            HStack(spacing: 4) {
                Text("Xem tr√™n GitHub")
                Image(systemName: "arrow.up.right")
            }
            .font(.caption)
            .foregroundStyle(.secondary)
        }
        .buttonStyle(.plain)
        .frame(maxWidth: .infinity)
        .padding(.vertical, 12)
        .background(colorScheme == .dark ? Color.white.opacity(0.02) : Color.black.opacity(0.02))
        .onHover { hovering in
            if hovering {
                NSCursor.pointingHand.push()
            } else {
                NSCursor.pop()
            }
        }
    }
}

#Preview {
    UpdateView()
}
</file>

<file path="scripts/build-macos.sh">
#!/bin/bash
set -e

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

# Parse arguments
CLEAN_INSTALL=false
for arg in "$@"; do
    case $arg in
        --clean)
            CLEAN_INSTALL=true
            shift
            ;;
        --help|-h)
            echo "Usage: build-macos.sh [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --clean    Remove existing GoNhanh app and clear permissions before building"
            echo "  --help     Show this help message"
            exit 0
            ;;
    esac
done

# Clean install: remove existing app and reset permissions
if [ "$CLEAN_INSTALL" = true ]; then
    echo "üßπ Cleaning existing installation..."

    # Kill running GoNhanh processes
    if pgrep -f "GoNhanh" > /dev/null 2>&1; then
        echo "Stopping running GoNhanh processes..."
        pkill -f "GoNhanh" 2>/dev/null || true
        # Wait for process to terminate
        sleep 1
        # Force kill if still running
        if pgrep -f "GoNhanh" > /dev/null 2>&1; then
            echo "Force killing GoNhanh..."
            pkill -9 -f "GoNhanh" 2>/dev/null || true
            sleep 1
        fi
        echo "GoNhanh processes stopped."
    else
        echo "No running GoNhanh process found."
    fi

    # Remove from /Applications (requires sudo)
    if [ -d "/Applications/GoNhanh.app" ]; then
        echo "Removing /Applications/GoNhanh.app (requires sudo)..."
        sudo rm -rf "/Applications/GoNhanh.app"
    fi

    # Remove from Input Methods
    if [ -d "$HOME/Library/Input Methods/GoNhanh.app" ]; then
        echo "Removing ~/Library/Input Methods/GoNhanh.app..."
        rm -rf "$HOME/Library/Input Methods/GoNhanh.app"
    fi

    # Clear TCC database (Accessibility permissions) - requires Full Disk Access or SIP disabled
    echo "Note: To fully reset Accessibility permissions, go to:"
    echo "  System Settings > Privacy & Security > Accessibility"
    echo "  Remove GoNhanh from the list manually"
    echo ""

    # Clear input source registration
    echo "Clearing input source cache..."
    defaults delete com.apple.HIToolbox AppleEnabledInputSources 2>/dev/null || true

    echo "‚úÖ Clean complete!"
    echo ""
fi

# Always kill running GoNhanh before build (even without --clean)
if pgrep -x "GoNhanh" > /dev/null 2>&1; then
    echo "üõë Stopping running GoNhanh..."
    pkill -x "GoNhanh" 2>/dev/null || true
    sleep 0.5
    # Force kill if still running
    if pgrep -x "GoNhanh" > /dev/null 2>&1; then
        pkill -9 -x "GoNhanh" 2>/dev/null || true
        sleep 0.5
    fi
fi

echo "üçé Building macOS app..."

# Get version from git tag
GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
VERSION=${GIT_TAG#v}  # Remove 'v' prefix
echo "üìå Version from git tag: $VERSION"

# Build macOS app with xcodebuild
cd "$(dirname "$0")/../platforms/macos"

if [ -d "GoNhanh.xcodeproj" ]; then
    echo "Building with Xcode..."

    # Build with version from git tag
    xcodebuild -scheme GoNhanh \
        -configuration Release \
        -destination 'platform=macOS,arch=arm64' \
        -destination 'platform=macOS,arch=x86_64' \
        -derivedDataPath "$(pwd)/build/DerivedData" \
        MARKETING_VERSION="$VERSION" \
        CURRENT_PROJECT_VERSION="$VERSION" \
        2>&1 | grep -v "Using the first of multiple matching destinations"

    # Copy app from DerivedData to local build directory
    echo "Copying app to build directory..."
    mkdir -p build/Release
    cp -R "build/DerivedData/Build/Products/Release/GoNhanh.app" build/Release/

    # Re-sign app with entitlements for local development
    echo "Signing app with entitlements..."
    codesign --force --deep --sign - --entitlements GoNhanh.entitlements build/Release/GoNhanh.app

    echo "‚úÖ macOS app built successfully!"
    echo "üì¶ App: platforms/macos/build/Release/GoNhanh.app"
else
    echo "‚ö†Ô∏è  Xcode project not found!"
    echo "Please create Xcode project in platforms/macos/"
    echo "Steps:"
    echo "  1. Open Xcode"
    echo "  2. Create new macOS App project"
    echo "  3. Name: GoNhanh"
    echo "  4. Location: platforms/macos/"
    echo "  5. Add Swift files from GoNhanh/ folder"
    echo "  6. Link libgonhanh_core.a in Build Phases"
fi
</file>

<file path="core/src/data/constants.rs">
//! Vietnamese Phonological Constants
//!
//! Centralized constants for valid initials, finals, and spelling rules.

use crate::data::keys;

/// Valid single initial consonants
pub const VALID_INITIALS_1: &[u16] = &[
    keys::B,
    keys::C,
    keys::D,
    keys::G,
    keys::H,
    keys::K,
    keys::L,
    keys::M,
    keys::N,
    keys::P,
    keys::Q,
    keys::R,
    keys::S,
    keys::T,
    keys::V,
    keys::X,
];

/// Valid double initial consonants
pub const VALID_INITIALS_2: &[[u16; 2]] = &[
    [keys::C, keys::H], // ch
    [keys::G, keys::H], // gh
    [keys::G, keys::I], // gi
    [keys::K, keys::H], // kh
    [keys::N, keys::G], // ng
    [keys::N, keys::H], // nh
    [keys::P, keys::H], // ph
    [keys::Q, keys::U], // qu
    [keys::T, keys::H], // th
    [keys::T, keys::R], // tr
];

/// Valid single final consonants
pub const VALID_FINALS_1: &[u16] = &[
    keys::C,
    keys::M,
    keys::N,
    keys::P,
    keys::T,
    keys::I,
    keys::Y,
    keys::O,
    keys::U, // semi-vowels
];

/// Valid double final consonants
pub const VALID_FINALS_2: &[[u16; 2]] = &[
    [keys::C, keys::H], // ch
    [keys::N, keys::G], // ng
    [keys::N, keys::H], // nh
];

/// Spelling rules: (consonant, invalid_vowels, description)
/// If consonant + vowel matches, it's INVALID
pub const SPELLING_RULES: &[(&[u16], &[u16], &str)] = &[
    // c before e, i, y ‚Üí invalid (should use k)
    (&[keys::C], &[keys::E, keys::I, keys::Y], "c before e/i/y"),
    // k before a, o, u ‚Üí invalid (should use c)
    (&[keys::K], &[keys::A, keys::O, keys::U], "k before a/o/u"),
    // g before e ‚Üí invalid (should use gh)
    (&[keys::G], &[keys::E], "g before e"),
    // ng before e, i ‚Üí invalid (should use ngh)
    (&[keys::N, keys::G], &[keys::E, keys::I], "ng before e/i"),
    // gh before a, o, u ‚Üí invalid (should use g)
    (
        &[keys::G, keys::H],
        &[keys::A, keys::O, keys::U],
        "gh before a/o/u",
    ),
    // ngh before a, o, u ‚Üí invalid (should use ng)
    (
        &[keys::N, keys::G, keys::H],
        &[keys::A, keys::O, keys::U],
        "ngh before a/o/u",
    ),
];
</file>

<file path="core/src/input/mod.rs">
//! Input Methods
//!
//! Defines key mappings for Vietnamese input methods.
//! Engine handles all pattern matching based on buffer scan.

pub mod telex;
pub mod vni;

pub use telex::Telex;
pub use vni::Vni;

use crate::data::chars::tone;
use crate::data::keys;

/// Shared tone target constants
pub const CIRCUMFLEX_TARGETS: &[u16] = &[keys::A, keys::E, keys::O];
pub const HORN_TARGETS_TELEX: &[u16] = &[keys::A, keys::O, keys::U];
pub const HORN_TARGETS_VNI: &[u16] = &[keys::O, keys::U];
pub const BREVE_TARGETS: &[u16] = &[keys::A];

/// Tone modifier type
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ToneType {
    /// Circumflex: √¢, √™, √¥
    Circumflex,
    /// Horn: ∆°, ∆∞ (and ƒÉ for Telex)
    Horn,
    /// Breve: ƒÉ (VNI only)
    Breve,
}

impl ToneType {
    pub fn value(&self) -> u8 {
        match self {
            ToneType::Circumflex => tone::CIRCUMFLEX,
            ToneType::Horn => tone::HORN,
            ToneType::Breve => tone::HORN, // ƒÉ uses same internal value
        }
    }
}

/// Input method trait - defines key mappings only
pub trait Method {
    /// Check if key is a mark modifier
    /// Returns: 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
    fn mark(&self, key: u16) -> Option<u8>;

    /// Check if key is a tone modifier
    /// Returns tone type if this key can modify vowels
    fn tone(&self, key: u16) -> Option<ToneType>;

    /// Get valid targets for tone key
    /// Returns list of vowel keys this tone can apply to
    fn tone_targets(&self, key: u16) -> &'static [u16];

    /// Check if key is stroke modifier (d ‚Üí ƒë)
    fn stroke(&self, key: u16) -> bool;

    /// Check if key removes diacritics
    fn remove(&self, key: u16) -> bool;
}

/// Get method by id
pub fn get(id: u8) -> Box<dyn Method> {
    match id {
        1 => Box::new(Vni),
        _ => Box::new(Telex),
    }
}
</file>

<file path="core/src/input/telex.rs">
//! Telex Input Method
//!
//! Key mappings:
//! - Marks: s=s·∫Øc, f=huy·ªÅn, r=h·ªèi, x=ng√£, j=n·∫∑ng
//! - Tones: a/e/o=circumflex, w=horn/breve
//! - Stroke: d
//! - Remove: z

use super::{Method, ToneType, HORN_TARGETS_TELEX};
use crate::data::keys;

pub struct Telex;

impl Method for Telex {
    fn mark(&self, key: u16) -> Option<u8> {
        match key {
            keys::S => Some(1), // s·∫Øc
            keys::F => Some(2), // huy·ªÅn
            keys::R => Some(3), // h·ªèi
            keys::X => Some(4), // ng√£
            keys::J => Some(5), // n·∫∑ng
            _ => None,
        }
    }

    fn tone(&self, key: u16) -> Option<ToneType> {
        match key {
            keys::A | keys::E | keys::O => Some(ToneType::Circumflex),
            keys::W => Some(ToneType::Horn),
            _ => None,
        }
    }

    fn tone_targets(&self, key: u16) -> &'static [u16] {
        match key {
            keys::A => &[keys::A],
            keys::E => &[keys::E],
            keys::O => &[keys::O],
            keys::W => HORN_TARGETS_TELEX,
            _ => &[],
        }
    }

    fn stroke(&self, key: u16) -> bool {
        key == keys::D
    }

    fn remove(&self, key: u16) -> bool {
        key == keys::Z
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_marks() {
        let t = Telex;
        assert_eq!(t.mark(keys::S), Some(1));
        assert_eq!(t.mark(keys::F), Some(2));
        assert_eq!(t.mark(keys::A), None);
    }

    #[test]
    fn test_tones() {
        let t = Telex;
        assert_eq!(t.tone(keys::A), Some(ToneType::Circumflex));
        assert_eq!(t.tone(keys::W), Some(ToneType::Horn));
        assert_eq!(t.tone(keys::B), None);
    }

    #[test]
    fn test_tone_targets() {
        let t = Telex;
        assert_eq!(t.tone_targets(keys::A), &[keys::A]);
        assert_eq!(t.tone_targets(keys::W), HORN_TARGETS_TELEX);
    }
}
</file>

<file path="platforms/macos/App.swift">
import SwiftUI

@main
struct GoNhanhApp: App {
    @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

    var body: some Scene {
        Settings {
            EmptyView()
        }
    }
}

class AppDelegate: NSObject, NSApplicationDelegate {
    var menuBar: MenuBarController?

    func applicationDidFinishLaunching(_ notification: Notification) {
        NSApp.setActivationPolicy(.accessory)
        menuBar = MenuBarController()
    }

    func applicationWillTerminate(_ notification: Notification) {
        KeyboardHookManager.shared.stop()
    }
}
</file>

<file path="platforms/macos/RustBridge.swift">
import Foundation
import Carbon
import AppKit

// MARK: - Debug Logging

// Only log when /tmp/gonhanh_debug.log exists (touch /tmp/gonhanh_debug.log to enable)
func debugLog(_ message: String) {
    let logPath = "/tmp/gonhanh_debug.log"
    guard FileManager.default.fileExists(atPath: logPath) else { return }

    let timestamp = ISO8601DateFormatter().string(from: Date())
    let logMessage = "[\(timestamp)] \(message)\n"

    if let handle = FileHandle(forWritingAtPath: logPath) {
        handle.seekToEndOfFile()
        if let data = logMessage.data(using: .utf8) {
            handle.write(data)
        }
        handle.closeFile()
    }
}

// MARK: - FFI Result Struct (must match Rust #[repr(C)])

struct ImeResult {
    var chars: (UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32,
                UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32,
                UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32,
                UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32, UInt32)
    var action: UInt8      // 0=None, 1=Send, 2=Restore
    var backspace: UInt8
    var count: UInt8
    var _pad: UInt8
}

// MARK: - C Function Declarations

@_silgen_name("ime_init")
func ime_init()

@_silgen_name("ime_key")
func ime_key(_ key: UInt16, _ caps: Bool, _ ctrl: Bool) -> UnsafeMutablePointer<ImeResult>?

@_silgen_name("ime_method")
func ime_method(_ method: UInt8)

@_silgen_name("ime_enabled")
func ime_enabled(_ enabled: Bool)

@_silgen_name("ime_clear")
func ime_clear()

@_silgen_name("ime_free")
func ime_free(_ result: UnsafeMutablePointer<ImeResult>?)

// MARK: - RustBridge

class RustBridge {
    static var isInitialized = false

    /// Initialize engine (call once at app start)
    static func initialize() {
        guard !isInitialized else { return }
        ime_init()
        isInitialized = true
        debugLog("[RustBridge] Engine initialized")
    }

    /// Process key event
    /// Returns: (backspaceCount, newChars) or nil if no action needed
    static func processKey(keyCode: UInt16, caps: Bool, ctrl: Bool) -> (Int, [Character])? {
        guard isInitialized else {
            debugLog("[RustBridge] Engine not initialized!")
            return nil
        }

        guard let resultPtr = ime_key(keyCode, caps, ctrl) else {
            return nil
        }
        defer { ime_free(resultPtr) }

        let result = resultPtr.pointee

        // Action: 0=None, 1=Send, 2=Restore
        guard result.action == 1 else {
            return nil
        }

        let backspace = Int(result.backspace)
        var chars: [Character] = []

        // Extract chars from tuple
        let charArray = withUnsafePointer(to: result.chars) { ptr in
            ptr.withMemoryRebound(to: UInt32.self, capacity: 32) { bound in
                Array(UnsafeBufferPointer(start: bound, count: Int(result.count)))
            }
        }

        for code in charArray {
            if let scalar = Unicode.Scalar(code) {
                chars.append(Character(scalar))
            }
        }

        return (backspace, chars)
    }

    /// Set input method (0=Telex, 1=VNI)
    static func setMethod(_ method: Int) {
        ime_method(UInt8(method))
        debugLog("[RustBridge] Method set to: \(method == 0 ? "Telex" : "VNI")")
    }

    /// Enable/disable engine
    static func setEnabled(_ enabled: Bool) {
        ime_enabled(enabled)
        debugLog("[RustBridge] Engine enabled: \(enabled)")
    }

    /// Clear buffer (new session, e.g., on mouse click)
    static func clearBuffer() {
        ime_clear()
    }
}

// MARK: - Keyboard Hook Manager

class KeyboardHookManager {
    static let shared = KeyboardHookManager()

    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var isRunning = false

    private init() {}

    func start() {
        guard !isRunning else { return }

        debugLog("[KeyboardHook] Starting...")

        // Check accessibility permission
        let trusted = AXIsProcessTrusted()
        debugLog("[KeyboardHook] Accessibility trusted: \(trusted)")

        if !trusted {
            // Prompt user for permission
            let options = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true] as CFDictionary
            AXIsProcessTrustedWithOptions(options)
            debugLog("[KeyboardHook] Requested accessibility permission. Please grant and restart app.")
            return
        }

        // Initialize Rust engine
        RustBridge.initialize()

        // Create event tap for keyDown events
        // Use listenOnly option which doesn't require as strict permissions
        let eventMask: CGEventMask = (1 << CGEventType.keyDown.rawValue)

        debugLog("[KeyboardHook] Creating event tap...")

        // Try creating tap - use .cghidEventTap for better compatibility
        var tap: CFMachPort?

        // First try session tap with defaultTap (can modify events)
        tap = CGEvent.tapCreate(
            tap: .cghidEventTap,
            place: .headInsertEventTap,
            options: .defaultTap,
            eventsOfInterest: eventMask,
            callback: keyboardCallback,
            userInfo: nil
        )

        if tap == nil {
            debugLog("[KeyboardHook] cghidEventTap failed, trying cgSessionEventTap...")
            tap = CGEvent.tapCreate(
                tap: .cgSessionEventTap,
                place: .headInsertEventTap,
                options: .defaultTap,
                eventsOfInterest: eventMask,
                callback: keyboardCallback,
                userInfo: nil
            )
        }

        if tap == nil {
            debugLog("[KeyboardHook] cgSessionEventTap failed, trying cgAnnotatedSessionEventTap...")
            tap = CGEvent.tapCreate(
                tap: .cgAnnotatedSessionEventTap,
                place: .headInsertEventTap,
                options: .defaultTap,
                eventsOfInterest: eventMask,
                callback: keyboardCallback,
                userInfo: nil
            )
        }

        guard let finalTap = tap else {
            debugLog("[KeyboardHook] ALL event tap methods FAILED!")
            debugLog("[KeyboardHook] Opening System Settings for Input Monitoring...")

            // Show alert and open System Settings
            DispatchQueue.main.async {
                let alert = NSAlert()
                alert.messageText = "C·∫ßn quy·ªÅn Accessibility"
                alert.informativeText = "GoNhanh c·∫ßn quy·ªÅn Accessibility ƒë·ªÉ g√µ ti·∫øng Vi·ªát.\n\n1. M·ªü System Settings > Privacy & Security > Accessibility\n2. B·∫≠t GoNhanh\n3. Kh·ªüi ƒë·ªông l·∫°i app"
                alert.alertStyle = .warning
                alert.addButton(withTitle: "M·ªü System Settings")
                alert.addButton(withTitle: "H·ªßy")

                if alert.runModal() == .alertFirstButtonReturn {
                    // Open Accessibility settings
                    if let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility") {
                        NSWorkspace.shared.open(url)
                    }
                }
            }
            return
        }

        debugLog("[KeyboardHook] Event tap created successfully")

        eventTap = finalTap
        runLoopSource = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, finalTap, 0)

        if let source = runLoopSource {
            CFRunLoopAddSource(CFRunLoopGetCurrent(), source, .commonModes)
            CGEvent.tapEnable(tap: finalTap, enable: true)
            isRunning = true
            debugLog("[KeyboardHook] Started successfully, listening for keys...")
        }
    }

    func stop() {
        guard isRunning else { return }

        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
        }

        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetCurrent(), source, .commonModes)
        }

        eventTap = nil
        runLoopSource = nil
        isRunning = false
        debugLog("[KeyboardHook] Stopped")
    }

    func getTap() -> CFMachPort? {
        return eventTap
    }
}

// MARK: - Global Hotkey

enum GlobalHotkey {
    static let toggleKey: CGKeyCode = 0x31 // Space

    static func isToggleHotkey(_ keyCode: UInt16, _ flags: CGEventFlags) -> Bool {
        keyCode == toggleKey && flags.contains(.maskControl) && !flags.contains(.maskCommand)
    }
}

// MARK: - Keyboard Callback

private func keyboardCallback(
    proxy: CGEventTapProxy,
    type: CGEventType,
    event: CGEvent,
    refcon: UnsafeMutableRawPointer?
) -> Unmanaged<CGEvent>? {

    // Handle tap disabled event - re-enable
    if type == .tapDisabledByTimeout || type == .tapDisabledByUserInput {
        debugLog("[KeyboardHook] Event tap was disabled, re-enabling...")
        if let tap = KeyboardHookManager.shared.getTap() {
            CGEvent.tapEnable(tap: tap, enable: true)
        }
        return Unmanaged.passUnretained(event)
    }

    // Only handle key down
    guard type == .keyDown else {
        return Unmanaged.passUnretained(event)
    }

    let keyCode = UInt16(event.getIntegerValueField(.keyboardEventKeycode))
    let flags = event.flags

    // Global hotkey: Ctrl+Space to toggle Vietnamese/English
    if GlobalHotkey.isToggleHotkey(keyCode, flags) {
        DispatchQueue.main.async {
            NotificationCenter.default.post(name: .toggleVietnamese, object: nil)
        }
        return nil // Consume the event
    }

    let caps = flags.contains(.maskShift) || flags.contains(.maskAlphaShift)
    let ctrl = flags.contains(.maskCommand) || flags.contains(.maskControl) ||
               flags.contains(.maskAlternate)

    debugLog("[KeyboardHook] Key: \(keyCode), caps=\(caps), ctrl=\(ctrl)")

    // Process key through Rust engine
    if let (backspace, chars) = RustBridge.processKey(keyCode: keyCode, caps: caps, ctrl: ctrl) {
        let charsStr = String(chars)
        debugLog("[KeyboardHook] Rust returned: backspace=\(backspace), chars=\"\(charsStr)\" (count=\(chars.count))")

        // Use atomic text replacement to fix Chrome/Excel autocomplete issues
        // Instead of backspace+type (which can cause "d√≠nh ch·ªØ"), we:
        // 1. Select text with Shift+Left
        // 2. Type replacement (automatically replaces selection)
        let useSelection = needsSelectionWorkaround()
        debugLog("[KeyboardHook] Method: \(useSelection ? "Selection" : "Backspace")")
        sendTextReplacement(backspaceCount: backspace, chars: chars)

        // Consume original event
        debugLog("[KeyboardHook] Original event CONSUMED (returning nil)")
        return nil
    }

    // Pass through
    debugLog("[KeyboardHook] Pass through (no transform)")
    return Unmanaged.passUnretained(event)
}

// MARK: - App Detection

/// Check if current app has autocomplete issues that need Shift+Left workaround
private func needsSelectionWorkaround() -> Bool {
    guard let frontApp = NSWorkspace.shared.frontmostApplication else {
        return false
    }

    let bundleId = frontApp.bundleIdentifier ?? ""

    // Apps with autocomplete that cause "d√≠nh ch·ªØ" issue
    let autocompleteApps = [
        "com.google.Chrome",
        "com.microsoft.edgemac",
        "com.microsoft.Excel",
        "com.microsoft.Word",
        "com.microsoft.Powerpoint",
        "com.apple.Safari",
        "org.mozilla.firefox",
        "com.google.android.studio",
    ]

    for id in autocompleteApps {
        if bundleId.hasPrefix(id) {
            return true
        }
    }

    return false
}

// MARK: - Key Codes

private enum KeyCode {
    static let backspace: CGKeyCode = 0x33
    static let leftArrow: CGKeyCode = 0x7B
}

// MARK: - Send Keys

/// Smart text replacement - uses different methods based on app type
/// - Default: Use backspace (works for most apps including Terminal)
/// - Autocomplete apps (Chrome/Excel): Use Shift+Left selection (fixes "d√≠nh ch·ªØ")
private func sendTextReplacement(backspaceCount: Int, chars: [Character]) {
    // Run synchronously to ensure events are sent before callback returns
    // This prevents race condition where next key arrives before backspace is processed
    if needsSelectionWorkaround() {
        sendTextReplacementWithSelection(backspaceCount: backspaceCount, chars: chars)
    } else {
        sendTextReplacementWithBackspace(backspaceCount: backspaceCount, chars: chars)
    }
}

/// Default method: backspace then type
private func sendTextReplacementWithBackspace(backspaceCount: Int, chars: [Character]) {
    let string = String(chars)
    debugLog("[Send:BS] START - backspace=\(backspaceCount), chars=\"\(string)\" (len=\(chars.count))")

    guard let source = CGEventSource(stateID: .privateState) else {
        debugLog("[Send:BS] FAILED - Cannot create CGEventSource")
        return
    }
    debugLog("[Send:BS] CGEventSource created OK")

    // Send backspaces with micro-delay between each
    for i in 0..<backspaceCount {
        guard let down = CGEvent(keyboardEventSource: source, virtualKey: KeyCode.backspace, keyDown: true),
              let up = CGEvent(keyboardEventSource: source, virtualKey: KeyCode.backspace, keyDown: false) else {
            debugLog("[Send:BS] FAILED - Cannot create backspace event \(i)")
            continue
        }
        down.post(tap: .cgSessionEventTap)
        up.post(tap: .cgSessionEventTap)
        // Micro-delay between backspaces to ensure each is processed
        if i < backspaceCount - 1 {
            usleep(200) // 0.2ms between backspaces
        }
        debugLog("[Send:BS] Backspace \(i+1)/\(backspaceCount) sent")
    }

    // Delay after all backspaces before typing replacement
    if backspaceCount > 0 {
        usleep(800) // 0.8ms delay
        debugLog("[Send:BS] Delay after backspaces")
    }

    // Send new characters
    let utf16 = Array(string.utf16)
    debugLog("[Send:BS] Sending unicode: \(utf16.map { String(format: "0x%04X", $0) }.joined(separator: " "))")

    guard let down = CGEvent(keyboardEventSource: source, virtualKey: 0, keyDown: true),
          let up = CGEvent(keyboardEventSource: source, virtualKey: 0, keyDown: false) else {
        debugLog("[Send:BS] FAILED - Cannot create unicode event for: \(string)")
        return
    }
    down.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    up.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    down.post(tap: .cgSessionEventTap)
    up.post(tap: .cgSessionEventTap)

    // Small delay after posting to let events propagate before next key
    usleep(500) // 0.5ms
    debugLog("[Send:BS] DONE - Unicode event posted")
}

/// GUI app-friendly: select then replace (atomic, fixes Chrome/Excel autocomplete)
private func sendTextReplacementWithSelection(backspaceCount: Int, chars: [Character]) {
    guard let source = CGEventSource(stateID: .privateState) else {
        debugLog("[Send] Failed to create CGEventSource")
        return
    }

    if backspaceCount > 0 {
        // Select text with Shift+Left Arrow
        for i in 0..<backspaceCount {
            guard let down = CGEvent(keyboardEventSource: source, virtualKey: KeyCode.leftArrow, keyDown: true),
                  let up = CGEvent(keyboardEventSource: source, virtualKey: KeyCode.leftArrow, keyDown: false) else {
                debugLog("[Send] Failed to create shift+left event \(i)")
                continue
            }
            down.flags = .maskShift
            up.flags = .maskShift
            down.post(tap: .cgSessionEventTap)
            up.post(tap: .cgSessionEventTap)
        }
    }

    // Send replacement characters (replaces selection)
    let string = String(chars)
    let utf16 = Array(string.utf16)

    guard let down = CGEvent(keyboardEventSource: source, virtualKey: 0, keyDown: true),
          let up = CGEvent(keyboardEventSource: source, virtualKey: 0, keyDown: false) else {
        debugLog("[Send] Failed to create unicode event for: \(string)")
        return
    }
    down.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    up.keyboardSetUnicodeString(stringLength: utf16.count, unicodeString: utf16)
    down.post(tap: .cgSessionEventTap)
    up.post(tap: .cgSessionEventTap)
}

// MARK: - Notifications

extension Notification.Name {
    static let toggleVietnamese = Notification.Name("toggleVietnamese")
}
</file>

<file path="platforms/macos/UpdateManager.swift">
import Foundation
import AppKit

// MARK: - Update State

enum UpdateState {
    case idle
    case checking
    case available(UpdateInfo)
    case upToDate
    case downloading(progress: Double)
    case readyToInstall(dmgPath: URL)
    case error(String)
}

// MARK: - Update Manager

class UpdateManager: NSObject, ObservableObject {
    static let shared = UpdateManager()

    @Published var state: UpdateState = .idle
    @Published var lastCheckDate: Date?

    private var downloadTask: URLSessionDownloadTask?
    private var downloadedDMGPath: URL?

    private let autoCheckInterval: TimeInterval = 24 * 60 * 60  // 24 hours
    private let autoCheckKey = "gonhanh.update.lastCheck"
    private let skipVersionKey = "gonhanh.update.skipVersion"

    private override init() {
        super.init()
        lastCheckDate = UserDefaults.standard.object(forKey: autoCheckKey) as? Date
    }

    // MARK: - Public API

    /// Check for updates manually (UI will show in UpdateView)
    func checkForUpdatesManually() {
        checkForUpdates(silent: false)
    }

    /// Check for updates silently (background check)
    func checkForUpdatesSilently() {
        if let lastCheck = lastCheckDate,
           Date().timeIntervalSince(lastCheck) < autoCheckInterval {
            return
        }
        checkForUpdates(silent: true)
    }

    /// Download the update
    func downloadUpdate(_ info: UpdateInfo) {
        state = .downloading(progress: 0)

        let session = URLSession(configuration: .default, delegate: self, delegateQueue: .main)
        downloadTask = session.downloadTask(with: info.downloadURL)
        downloadTask?.resume()
    }

    /// Install the downloaded update
    func installUpdate() {
        guard case .readyToInstall(let dmgPath) = state else { return }

        // Open the DMG file
        NSWorkspace.shared.open(dmgPath)

        // Quit the app to allow replacement
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            NSApp.terminate(nil)
        }
    }

    /// Skip this version
    func skipVersion(_ version: String) {
        UserDefaults.standard.set(version, forKey: skipVersionKey)
        state = .idle
    }

    /// Cancel ongoing download
    func cancelDownload() {
        downloadTask?.cancel()
        downloadTask = nil
        state = .idle
    }

    // MARK: - Private Methods

    private func checkForUpdates(silent: Bool) {
        if !silent {
            state = .checking
        }

        UpdateChecker.shared.checkForUpdates { [weak self] result in
            guard let self = self else { return }

            // Save check date
            self.lastCheckDate = Date()
            UserDefaults.standard.set(self.lastCheckDate, forKey: self.autoCheckKey)

            switch result {
            case .available(let info):
                // Check if user skipped this version
                let skippedVersion = UserDefaults.standard.string(forKey: self.skipVersionKey)
                if silent && skippedVersion == info.version {
                    self.state = .idle
                    return
                }

                self.state = .available(info)

                // Only show notification for background check
                if silent {
                    self.showUpdateNotification(info)
                }

            case .upToDate:
                self.state = .upToDate

            case .error(let message):
                self.state = .error(message)
            }
        }
    }

    // MARK: - Notification (for background check only)

    private func showUpdateNotification(_ info: UpdateInfo) {
        let notification = NSUserNotification()
        notification.title = "GoNhanh - C√≥ phi√™n b·∫£n m·ªõi"
        notification.informativeText = "Phi√™n b·∫£n \(info.version) ƒë√£ s·∫µn s√†ng ƒë·ªÉ t·∫£i v·ªÅ."
        notification.soundName = NSUserNotificationDefaultSoundName
        notification.hasActionButton = true
        notification.actionButtonTitle = "Xem"

        NSUserNotificationCenter.default.deliver(notification)
    }
}

// MARK: - URLSession Download Delegate

extension UpdateManager: URLSessionDownloadDelegate {
    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) {
        let downloadsURL = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
        let destinationURL = downloadsURL.appendingPathComponent("GoNhanh.dmg")

        do {
            try? FileManager.default.removeItem(at: destinationURL)
            try FileManager.default.moveItem(at: location, to: destinationURL)

            downloadedDMGPath = destinationURL
            state = .readyToInstall(dmgPath: destinationURL)

        } catch {
            state = .error("Kh√¥ng th·ªÉ l∆∞u file: \(error.localizedDescription)")
        }
    }

    func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) {
        let progress = Double(totalBytesWritten) / Double(totalBytesExpectedToWrite)
        state = .downloading(progress: progress)
    }

    func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        if let error = error {
            if (error as NSError).code == NSURLErrorCancelled {
                state = .idle
            } else {
                state = .error("T·∫£i v·ªÅ th·∫•t b·∫°i: \(error.localizedDescription)")
            }
        }
    }
}
</file>

<file path="core/src/engine/buffer.rs">
//! Typing buffer

pub const MAX: usize = 32;

use crate::utils;

/// Single character in buffer
///
/// Modifiers:
/// - `tone`: vowel diacritics (^, horn, breve)
/// - `mark`: tone marks (s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng)
/// - `stroke`: consonant stroke (d ‚Üí ƒë)
#[derive(Clone, Copy, Default)]
pub struct Char {
    pub key: u16,
    pub caps: bool,
    pub tone: u8,     // 0=none, 1=circumflex(^), 2=horn/breve
    pub mark: u8,     // 0=none, 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
    pub stroke: bool, // true if 'd' ‚Üí 'ƒë' (stroke through)
}

impl Char {
    pub fn new(key: u16, caps: bool) -> Self {
        Self {
            key,
            caps,
            tone: 0,
            mark: 0,
            stroke: false,
        }
    }

    pub fn has_tone(&self) -> bool {
        self.tone > 0
    }

    pub fn has_mark(&self) -> bool {
        self.mark > 0
    }
}

/// Typing buffer
pub struct Buffer {
    data: [Char; MAX],
    len: usize,
}

impl Default for Buffer {
    fn default() -> Self {
        Self::new()
    }
}

impl Buffer {
    pub fn new() -> Self {
        Self {
            data: [Char::default(); MAX],
            len: 0,
        }
    }

    pub fn push(&mut self, c: Char) {
        if self.len < MAX {
            self.data[self.len] = c;
            self.len += 1;
        }
    }

    pub fn pop(&mut self) -> Option<Char> {
        if self.len > 0 {
            self.len -= 1;
            Some(self.data[self.len])
        } else {
            None
        }
    }

    pub fn clear(&mut self) {
        self.len = 0;
    }

    pub fn len(&self) -> usize {
        self.len
    }

    pub fn is_empty(&self) -> bool {
        self.len == 0
    }

    pub fn get(&self, i: usize) -> Option<&Char> {
        if i < self.len {
            Some(&self.data[i])
        } else {
            None
        }
    }

    pub fn get_mut(&mut self, i: usize) -> Option<&mut Char> {
        if i < self.len {
            Some(&mut self.data[i])
        } else {
            None
        }
    }

    pub fn last(&self) -> Option<&Char> {
        if self.len > 0 {
            Some(&self.data[self.len - 1])
        } else {
            None
        }
    }

    /// Find indices of vowels in buffer
    pub fn find_vowels(&self) -> Vec<usize> {
        use crate::data::keys;
        (0..self.len)
            .filter(|&i| keys::is_vowel(self.data[i].key))
            .collect()
    }

    /// Find vowel position by key (from end)
    pub fn find_vowel_by_key(&self, key: u16) -> Option<usize> {
        use crate::data::keys;
        (0..self.len)
            .rev()
            .find(|&i| self.data[i].key == key && keys::is_vowel(key))
    }

    /// Iterate over chars
    pub fn iter(&self) -> std::slice::Iter<'_, Char> {
        self.data[..self.len].iter()
    }

    /// Convert buffer to lowercase string (for shortcut matching)
    pub fn to_lowercase_string(&self) -> String {
        self.data[..self.len]
            .iter()
            .filter_map(|c| utils::key_to_char(c.key, false))
            .collect()
    }

    /// Convert buffer to string preserving case (for shortcut case matching)
    pub fn to_string_preserve_case(&self) -> String {
        use crate::data::keys;
        self.data[..self.len]
            .iter()
            .filter_map(|c| {
                let ch = match c.key {
                    keys::A => 'a',
                    keys::B => 'b',
                    keys::C => 'c',
                    keys::D => 'd',
                    keys::E => 'e',
                    keys::F => 'f',
                    keys::G => 'g',
                    keys::H => 'h',
                    keys::I => 'i',
                    keys::J => 'j',
                    keys::K => 'k',
                    keys::L => 'l',
                    keys::M => 'm',
                    keys::N => 'n',
                    keys::O => 'o',
                    keys::P => 'p',
                    keys::Q => 'q',
                    keys::R => 'r',
                    keys::S => 's',
                    keys::T => 't',
                    keys::U => 'u',
                    keys::V => 'v',
                    keys::W => 'w',
                    keys::X => 'x',
                    keys::Y => 'y',
                    keys::Z => 'z',
                    _ => return None,
                };
                Some(if c.caps { ch.to_ascii_uppercase() } else { ch })
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_buffer() {
        let mut buf = Buffer::new();
        assert!(buf.is_empty());

        buf.push(Char::new(0, false));
        buf.push(Char::new(1, true));
        assert_eq!(buf.len(), 2);

        let c = buf.pop().unwrap();
        assert_eq!(c.key, 1);
        assert!(c.caps);

        buf.clear();
        assert!(buf.is_empty());
    }
}
</file>

<file path="core/src/engine/transform.rs">
//! Vietnamese Transformation
//!
//! Pattern-based transformation for Vietnamese diacritics.
//! Scans entire buffer instead of case-by-case processing.

use super::buffer::Buffer;
use crate::data::vowel::Phonology;
use crate::data::{
    chars::{mark, tone},
    keys,
};
use crate::utils;

/// Modifier type detected from key
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ModifierType {
    /// Tone diacritic: circumflex (^), horn, breve
    Tone(u8),
    /// Tone mark: s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng
    Mark(u8),
    /// Stroke: d ‚Üí ƒë
    Stroke,
    /// Remove last diacritic
    Remove,
}

/// Transformation result
#[derive(Debug)]
pub struct TransformResult {
    /// Positions that were modified
    pub modified_positions: Vec<usize>,
    /// Whether transformation was applied
    pub applied: bool,
}

impl TransformResult {
    pub fn none() -> Self {
        Self {
            modified_positions: vec![],
            applied: false,
        }
    }

    pub fn success(positions: Vec<usize>) -> Self {
        Self {
            modified_positions: positions,
            applied: true,
        }
    }

    pub fn earliest_position(&self) -> Option<usize> {
        self.modified_positions.iter().copied().min()
    }
}

/// Apply tone diacritic transformation (^, ∆°, ∆∞, ƒÉ)
///
/// Pattern-based: scans buffer for matching vowels
pub fn apply_tone(buf: &mut Buffer, key: u16, tone_value: u8, method: u8) -> TransformResult {
    let buffer_keys: Vec<u16> = buf.iter().map(|c| c.key).collect();

    // Find target vowels based on key and method
    let targets = find_tone_targets(&buffer_keys, key, tone_value, method);

    if targets.is_empty() {
        return TransformResult::none();
    }

    // Apply tone to targets
    let mut positions = vec![];
    for pos in &targets {
        if let Some(c) = buf.get_mut(*pos) {
            if c.tone == tone::NONE {
                c.tone = tone_value;
                positions.push(*pos);
            }
        }
    }

    if positions.is_empty() {
        TransformResult::none()
    } else {
        // After adding tone, reposition mark if needed
        reposition_mark_if_needed(buf);
        TransformResult::success(positions)
    }
}

/// Find which vowel positions should receive the tone modifier
fn find_tone_targets(buffer_keys: &[u16], key: u16, tone_value: u8, method: u8) -> Vec<usize> {
    let mut targets = vec![];

    // Find all vowel positions
    let vowel_positions: Vec<usize> = buffer_keys
        .iter()
        .enumerate()
        .filter(|(_, &k)| keys::is_vowel(k))
        .map(|(i, _)| i)
        .collect();

    if vowel_positions.is_empty() {
        return targets;
    }

    // Telex patterns
    if method == 0 {
        // aa, ee, oo ‚Üí circumflex
        if tone_value == tone::CIRCUMFLEX && matches!(key, keys::A | keys::E | keys::O) {
            // Find matching vowel (same key)
            for &pos in vowel_positions.iter().rev() {
                if buffer_keys[pos] == key {
                    targets.push(pos);
                    break;
                }
            }
        }
        // w ‚Üí horn/breve
        else if tone_value == tone::HORN && key == keys::W {
            targets = find_horn_targets(buffer_keys, &vowel_positions);
        }
    }
    // VNI patterns
    else {
        // 6 ‚Üí circumflex for a, e, o
        if tone_value == tone::CIRCUMFLEX && key == keys::N6 {
            for &pos in vowel_positions.iter().rev() {
                if matches!(buffer_keys[pos], keys::A | keys::E | keys::O) {
                    targets.push(pos);
                    break;
                }
            }
        }
        // 7 ‚Üí horn for o, u
        else if tone_value == tone::HORN && key == keys::N7 {
            targets = find_horn_targets(buffer_keys, &vowel_positions);
        }
        // 8 ‚Üí breve for a only
        else if tone_value == tone::HORN && key == keys::N8 {
            for &pos in vowel_positions.iter().rev() {
                if buffer_keys[pos] == keys::A {
                    targets.push(pos);
                    break;
                }
            }
        }
    }

    targets
}

/// Find targets for horn modifier (∆°, ∆∞, ∆∞∆° compound)
///
/// Special: if "uo" adjacent, apply horn to BOTH (∆∞∆° compound)
fn find_horn_targets(buffer_keys: &[u16], vowel_positions: &[usize]) -> Vec<usize> {
    let mut targets = vec![];

    // Check for uo compound first
    let len = vowel_positions.len();
    if len >= 2 {
        for i in 0..len - 1 {
            let pos1 = vowel_positions[i];
            let pos2 = vowel_positions[i + 1];

            // Must be adjacent positions
            if pos2 == pos1 + 1 {
                let k1 = buffer_keys[pos1];
                let k2 = buffer_keys[pos2];

                // uo or ou compound
                if (k1 == keys::U && k2 == keys::O) || (k1 == keys::O && k2 == keys::U) {
                    // Apply to both
                    targets.push(pos1);
                    targets.push(pos2);
                    return targets;
                }
            }
        }
    }

    // No compound found, apply to single vowel (last a, o, or u)
    for &pos in vowel_positions.iter().rev() {
        let k = buffer_keys[pos];
        if matches!(k, keys::A | keys::O | keys::U) {
            targets.push(pos);
            break;
        }
    }

    targets
}

/// Apply mark transformation (s·∫Øc, huy·ªÅn, h·ªèi, ng√£, n·∫∑ng)
pub fn apply_mark(buf: &mut Buffer, mark_value: u8, modern: bool) -> TransformResult {
    let vowels = utils::collect_vowels(buf);
    if vowels.is_empty() {
        return TransformResult::none();
    }

    // Find position using phonology rules
    let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
    let has_final = utils::has_final_consonant(buf, last_vowel_pos);
    let has_qu = utils::has_qu_initial(buf);
    let pos = Phonology::find_tone_position(&vowels, has_final, modern, has_qu);

    // Clear any existing mark first
    for v in &vowels {
        if let Some(c) = buf.get_mut(v.pos) {
            c.mark = mark::NONE;
        }
    }

    // Apply new mark
    if let Some(c) = buf.get_mut(pos) {
        c.mark = mark_value;
        return TransformResult::success(vec![pos]);
    }

    TransformResult::none()
}

/// Apply stroke transformation (d ‚Üí ƒë)
///
/// Scans buffer for 'd' at any position
pub fn apply_stroke(buf: &mut Buffer) -> TransformResult {
    // Find first 'd' that hasn't been stroked
    for i in 0..buf.len() {
        if let Some(c) = buf.get_mut(i) {
            if c.key == keys::D && !c.stroke {
                c.stroke = true;
                return TransformResult::success(vec![i]);
            }
        }
    }
    TransformResult::none()
}

/// Remove last diacritic (mark first, then tone)
pub fn apply_remove(buf: &mut Buffer) -> TransformResult {
    let vowel_positions = buf.find_vowels();

    // Try to remove mark first
    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.mark > mark::NONE {
                c.mark = mark::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    // Then try to remove tone
    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.tone > tone::NONE {
                c.tone = tone::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    TransformResult::none()
}

/// Revert tone transformation
pub fn revert_tone(buf: &mut Buffer, target_key: u16) -> TransformResult {
    let vowel_positions = buf.find_vowels();

    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.key == target_key && c.tone > tone::NONE {
                c.tone = tone::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    TransformResult::none()
}

/// Revert mark transformation
pub fn revert_mark(buf: &mut Buffer) -> TransformResult {
    let vowel_positions = buf.find_vowels();

    for pos in vowel_positions.iter().rev() {
        if let Some(c) = buf.get_mut(*pos) {
            if c.mark > mark::NONE {
                c.mark = mark::NONE;
                return TransformResult::success(vec![*pos]);
            }
        }
    }

    TransformResult::none()
}

/// Revert stroke transformation
pub fn revert_stroke(buf: &mut Buffer) -> TransformResult {
    // Find stroked 'd' and un-stroke it
    for i in 0..buf.len() {
        if let Some(c) = buf.get_mut(i) {
            if c.key == keys::D && c.stroke {
                c.stroke = false;
                return TransformResult::success(vec![i]);
            }
        }
    }
    TransformResult::none()
}

/// Reposition mark after tone change if needed
fn reposition_mark_if_needed(buf: &mut Buffer) {
    // Find current mark
    let mark_info: Option<(usize, u8)> = buf
        .iter()
        .enumerate()
        .find(|(_, c)| c.mark > 0)
        .map(|(i, c)| (i, c.mark));

    if let Some((old_pos, mark_value)) = mark_info {
        let vowels = utils::collect_vowels(buf);
        if vowels.is_empty() {
            return;
        }

        let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
        let has_final = utils::has_final_consonant(buf, last_vowel_pos);
        let has_qu = utils::has_qu_initial(buf);
        let new_pos = Phonology::find_tone_position(&vowels, has_final, true, has_qu);

        if new_pos != old_pos {
            // Clear old mark
            if let Some(c) = buf.get_mut(old_pos) {
                c.mark = 0;
            }
            // Set new mark
            if let Some(c) = buf.get_mut(new_pos) {
                c.mark = mark_value;
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::super::buffer::Char;
    use super::*;

    fn setup_buffer(s: &str) -> Buffer {
        let mut buf = Buffer::new();
        for ch in s.chars() {
            let key = match ch.to_ascii_lowercase() {
                'a' => keys::A,
                'b' => keys::B,
                'c' => keys::C,
                'd' => keys::D,
                'e' => keys::E,
                'g' => keys::G,
                'h' => keys::H,
                'i' => keys::I,
                'n' => keys::N,
                'o' => keys::O,
                'u' => keys::U,
                _ => continue,
            };
            buf.push(Char::new(key, ch.is_uppercase()));
        }
        buf
    }

    #[test]
    fn test_apply_stroke() {
        let mut buf = setup_buffer("do");
        let result = apply_stroke(&mut buf);
        assert!(result.applied);
        assert!(buf.get(0).unwrap().stroke);
    }

    #[test]
    fn test_apply_stroke_anywhere() {
        // "dod" should stroke the first 'd'
        let mut buf = setup_buffer("dod");
        let result = apply_stroke(&mut buf);
        assert!(result.applied);
        assert!(buf.get(0).unwrap().stroke); // First d is stroked
    }

    #[test]
    fn test_apply_mark() {
        let mut buf = setup_buffer("an");
        let result = apply_mark(&mut buf, mark::SAC, true);
        assert!(result.applied);
        assert_eq!(buf.get(0).unwrap().mark, mark::SAC);
    }

    #[test]
    fn test_uo_compound() {
        let mut buf = setup_buffer("duoc");
        let result = apply_tone(&mut buf, keys::W, tone::HORN, 0);
        assert!(result.applied);
        // Both u and o should have horn
        assert_eq!(buf.get(1).unwrap().tone, tone::HORN); // u
        assert_eq!(buf.get(2).unwrap().tone, tone::HORN); // o
    }
}
</file>

<file path="core/src/input/vni.rs">
//! VNI Input Method
//!
//! Key mappings:
//! - Marks: 1=s·∫Øc, 2=huy·ªÅn, 3=h·ªèi, 4=ng√£, 5=n·∫∑ng
//! - Tones: 6=circumflex, 7=horn, 8=breve
//! - Stroke: 9
//! - Remove: 0

use super::{Method, ToneType, BREVE_TARGETS, CIRCUMFLEX_TARGETS, HORN_TARGETS_VNI};
use crate::data::keys;

pub struct Vni;

impl Method for Vni {
    fn mark(&self, key: u16) -> Option<u8> {
        match key {
            keys::N1 => Some(1), // s·∫Øc
            keys::N2 => Some(2), // huy·ªÅn
            keys::N3 => Some(3), // h·ªèi
            keys::N4 => Some(4), // ng√£
            keys::N5 => Some(5), // n·∫∑ng
            _ => None,
        }
    }

    fn tone(&self, key: u16) -> Option<ToneType> {
        match key {
            keys::N6 => Some(ToneType::Circumflex),
            keys::N7 => Some(ToneType::Horn),
            keys::N8 => Some(ToneType::Breve),
            _ => None,
        }
    }

    fn tone_targets(&self, key: u16) -> &'static [u16] {
        match key {
            keys::N6 => CIRCUMFLEX_TARGETS,
            keys::N7 => HORN_TARGETS_VNI,
            keys::N8 => BREVE_TARGETS,
            _ => &[],
        }
    }

    fn stroke(&self, key: u16) -> bool {
        key == keys::N9
    }

    fn remove(&self, key: u16) -> bool {
        key == keys::N0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_marks() {
        let v = Vni;
        assert_eq!(v.mark(keys::N1), Some(1));
        assert_eq!(v.mark(keys::N5), Some(5));
        assert_eq!(v.mark(keys::A), None);
    }

    #[test]
    fn test_tones() {
        let v = Vni;
        assert_eq!(v.tone(keys::N6), Some(ToneType::Circumflex));
        assert_eq!(v.tone(keys::N7), Some(ToneType::Horn));
        assert_eq!(v.tone(keys::N8), Some(ToneType::Breve));
    }

    #[test]
    fn test_stroke() {
        let v = Vni;
        assert!(v.stroke(keys::N9));
        assert!(!v.stroke(keys::D));
    }
}
</file>

<file path="core/src/utils.rs">
//! Shared utilities for Vietnamese IME processing
//!
//! Contains common functions used across engine modules to avoid duplication.
//! Also includes test utilities under #[cfg(test)].

use crate::data::{
    chars::tone,
    keys,
    vowel::{Modifier, Vowel},
};
use crate::engine::buffer::Buffer;

/// Convert key code to character
pub fn key_to_char(key: u16, caps: bool) -> Option<char> {
    let ch = match key {
        keys::A => 'a',
        keys::B => 'b',
        keys::C => 'c',
        keys::D => 'd',
        keys::E => 'e',
        keys::F => 'f',
        keys::G => 'g',
        keys::H => 'h',
        keys::I => 'i',
        keys::J => 'j',
        keys::K => 'k',
        keys::L => 'l',
        keys::M => 'm',
        keys::N => 'n',
        keys::O => 'o',
        keys::P => 'p',
        keys::Q => 'q',
        keys::R => 'r',
        keys::S => 's',
        keys::T => 't',
        keys::U => 'u',
        keys::V => 'v',
        keys::W => 'w',
        keys::X => 'x',
        keys::Y => 'y',
        keys::Z => 'z',
        keys::N0 => return Some('0'),
        keys::N1 => return Some('1'),
        keys::N2 => return Some('2'),
        keys::N3 => return Some('3'),
        keys::N4 => return Some('4'),
        keys::N5 => return Some('5'),
        keys::N6 => return Some('6'),
        keys::N7 => return Some('7'),
        keys::N8 => return Some('8'),
        keys::N9 => return Some('9'),
        _ => return None,
    };
    Some(if caps { ch.to_ascii_uppercase() } else { ch })
}

/// Collect vowels from buffer with phonological info
pub fn collect_vowels(buf: &Buffer) -> Vec<Vowel> {
    buf.iter()
        .enumerate()
        .filter(|(_, c)| keys::is_vowel(c.key))
        .map(|(pos, c)| {
            let modifier = match c.tone {
                tone::CIRCUMFLEX => Modifier::Circumflex,
                tone::HORN => Modifier::Horn,
                _ => Modifier::None,
            };
            Vowel::new(c.key, modifier, pos)
        })
        .collect()
}

/// Check if there's a consonant after position
pub fn has_final_consonant(buf: &Buffer, after_pos: usize) -> bool {
    (after_pos + 1..buf.len()).any(|i| {
        buf.get(i)
            .map(|c| keys::is_consonant(c.key))
            .unwrap_or(false)
    })
}

/// Check if 'q' precedes 'u' in buffer
pub fn has_qu_initial(buf: &Buffer) -> bool {
    for (i, c) in buf.iter().enumerate() {
        if c.key == keys::U && i > 0 {
            if let Some(prev) = buf.get(i - 1) {
                return prev.key == keys::Q;
            }
        }
    }
    false
}

mod test_utils {
    //! Shared test utilities for inline tests
    //!
    //! Provides common helpers for testing Vietnamese IME engine.
    //! Used by `#[cfg(test)]` modules throughout the crate.

    use crate::data::keys;
    use crate::engine::{Action, Engine};

    // ============================================================
    // KEY MAPPING
    // ============================================================

    /// Convert character to key code
    pub fn char_to_key(c: char) -> u16 {
        match c.to_ascii_lowercase() {
            'a' => keys::A,
            'b' => keys::B,
            'c' => keys::C,
            'd' => keys::D,
            'e' => keys::E,
            'f' => keys::F,
            'g' => keys::G,
            'h' => keys::H,
            'i' => keys::I,
            'j' => keys::J,
            'k' => keys::K,
            'l' => keys::L,
            'm' => keys::M,
            'n' => keys::N,
            'o' => keys::O,
            'p' => keys::P,
            'q' => keys::Q,
            'r' => keys::R,
            's' => keys::S,
            't' => keys::T,
            'u' => keys::U,
            'v' => keys::V,
            'w' => keys::W,
            'x' => keys::X,
            'y' => keys::Y,
            'z' => keys::Z,
            '0' => keys::N0,
            '1' => keys::N1,
            '2' => keys::N2,
            '3' => keys::N3,
            '4' => keys::N4,
            '5' => keys::N5,
            '6' => keys::N6,
            '7' => keys::N7,
            '8' => keys::N8,
            '9' => keys::N9,
            '<' => keys::DELETE,
            ' ' => keys::SPACE,
            _ => 255,
        }
    }

    /// Convert string to key codes
    pub fn keys_from_str(s: &str) -> Vec<u16> {
        s.chars().map(char_to_key).filter(|&k| k != 255).collect()
    }

    // ============================================================
    // TYPING SIMULATION
    // ============================================================

    /// Simulate typing, returns screen output
    pub fn type_word(e: &mut Engine, input: &str) -> String {
        let mut screen = String::new();
        for c in input.chars() {
            let key = char_to_key(c);
            let is_caps = c.is_uppercase();

            if key == keys::DELETE {
                screen.pop();
                e.on_key(key, false, false);
                continue;
            }

            if key == keys::SPACE {
                screen.push(' ');
                e.on_key(key, false, false);
                continue;
            }

            let r = e.on_key(key, is_caps, false);
            if r.action == Action::Send as u8 {
                for _ in 0..r.backspace {
                    screen.pop();
                }
                for i in 0..r.count as usize {
                    if let Some(ch) = char::from_u32(r.chars[i]) {
                        screen.push(ch);
                    }
                }
            } else if keys::is_letter(key) {
                screen.push(if is_caps {
                    c.to_ascii_uppercase()
                } else {
                    c.to_ascii_lowercase()
                });
            }
        }
        screen
    }

    // ============================================================
    // TEST RUNNERS
    // ============================================================

    /// Run Telex test cases
    pub fn telex(cases: &[(&str, &str)]) {
        for (input, expected) in cases {
            let mut e = Engine::new();
            let result = type_word(&mut e, input);
            assert_eq!(result, *expected, "[Telex] '{}' ‚Üí '{}'", input, result);
        }
    }

    /// Run VNI test cases
    pub fn vni(cases: &[(&str, &str)]) {
        for (input, expected) in cases {
            let mut e = Engine::new();
            e.set_method(1);
            let result = type_word(&mut e, input);
            assert_eq!(result, *expected, "[VNI] '{}' ‚Üí '{}'", input, result);
        }
    }
}

// Re-export test utilities for use in other test modules
pub use test_utils::*;
</file>

<file path="core/src/engine/syllable.rs">
//! Vietnamese Syllable Parser
//!
//! Parses buffer into syllable structure: (C‚ÇÅ)(G)V(C‚ÇÇ)
//! - C‚ÇÅ: Initial consonant (ph·ª• √¢m ƒë·∫ßu)
//! - G: Glide/Medial (√¢m ƒë·ªám)
//! - V: Vowel nucleus (nguy√™n √¢m ch√≠nh) - REQUIRED
//! - C‚ÇÇ: Final consonant (√¢m cu·ªëi)

use crate::data::constants;
use crate::data::keys;

/// Parsed syllable structure
#[derive(Debug, Clone, Default)]
pub struct Syllable {
    /// Initial consonant indices in buffer
    pub initial: Vec<usize>,
    /// Glide/medial index (o in "hoa", u in "qua")
    pub glide: Option<usize>,
    /// Vowel nucleus indices
    pub vowel: Vec<usize>,
    /// Final consonant indices
    pub final_c: Vec<usize>,
}

impl Syllable {
    pub fn is_empty(&self) -> bool {
        self.vowel.is_empty()
    }

    pub fn has_initial(&self) -> bool {
        !self.initial.is_empty()
    }

    pub fn has_final(&self) -> bool {
        !self.final_c.is_empty()
    }

    pub fn vowel_count(&self) -> usize {
        self.vowel.len()
    }
}

/// Valid final consonants (√¢m cu·ªëi)
const FINALS_2: &[[u16; 2]] = &[
    [keys::C, keys::H], // ch
    [keys::N, keys::G], // ng
    [keys::N, keys::H], // nh
];

/// Parse buffer keys into syllable structure
///
/// Uses longest-match-first algorithm:
/// 1. Match initial consonant (3 ‚Üí 2 ‚Üí 1 chars)
/// 2. Check for glide (o/u before main vowel)
/// 3. Match vowel nucleus
/// 4. Remainder is final consonant
///
/// Note: This parser is lenient - it will parse invalid initials
/// and let validation reject them later.
pub fn parse(buffer_keys: &[u16]) -> Syllable {
    let mut syllable = Syllable::default();
    let len = buffer_keys.len();

    if len == 0 {
        return syllable;
    }

    // Step 1: Find first vowel position, with special handling for "gi", "qu"
    let first_vowel_pos = buffer_keys.iter().position(|&k| keys::is_vowel(k));

    let vowel_start = match first_vowel_pos {
        Some(pos) => {
            // Special case: "gi" + vowel ‚Üí gi is initial, not g alone
            // Check if we have g + i + another_vowel pattern
            if pos > 0 && pos + 1 < len {
                let prev = buffer_keys[pos - 1];
                let curr = buffer_keys[pos];
                let next = buffer_keys[pos + 1];

                // gi + vowel (gi√†u, gi·∫øng, etc.)
                if prev == keys::G && curr == keys::I && keys::is_vowel(next) {
                    // Include 'i' in initial, not as vowel
                    for i in 0..=pos {
                        syllable.initial.push(i);
                    }
                    pos + 1 // vowels start after 'i'
                }
                // qu + vowel (qua, qu√™, etc.) - qu is initial
                else if prev == keys::Q && curr == keys::U && keys::is_vowel(next) {
                    // Include 'u' in initial, not as vowel
                    for i in 0..=pos {
                        syllable.initial.push(i);
                    }
                    pos + 1
                } else {
                    // Normal: everything before first vowel is initial
                    for i in 0..pos {
                        syllable.initial.push(i);
                    }
                    pos
                }
            } else {
                // Normal: everything before first vowel is initial
                for i in 0..pos {
                    syllable.initial.push(i);
                }
                pos
            }
        }
        None => {
            // No vowel found - invalid syllable
            return syllable;
        }
    };

    // Step 2: Find vowels and glide
    let mut vowel_end = vowel_start;

    // Find all consecutive vowels
    while vowel_end < len && keys::is_vowel(buffer_keys[vowel_end]) {
        vowel_end += 1;
    }

    if vowel_end == vowel_start {
        // No vowel found - invalid syllable (shouldn't happen here)
        return syllable;
    }

    // Check for glide pattern
    let vowel_count = vowel_end - vowel_start;
    if vowel_count >= 2 {
        let first_vowel = buffer_keys[vowel_start];
        let second_vowel = buffer_keys[vowel_start + 1];

        // Check if it's a glide pattern
        let is_glide = is_glide_pattern(first_vowel, second_vowel, &syllable);

        if is_glide {
            syllable.glide = Some(vowel_start);
            for i in (vowel_start + 1)..vowel_end {
                syllable.vowel.push(i);
            }
        } else {
            for i in vowel_start..vowel_end {
                syllable.vowel.push(i);
            }
        }
    } else {
        // Single vowel
        syllable.vowel.push(vowel_start);
    }

    // Step 3: Match final consonant
    if vowel_end < len {
        match_final(buffer_keys, vowel_end, &mut syllable);
    }

    syllable
}

/// Match final consonant
fn match_final(keys: &[u16], start: usize, syllable: &mut Syllable) {
    let len = keys.len();
    let remaining = len - start;

    // Try 2-char finals
    if remaining >= 2 {
        for pattern in FINALS_2 {
            if keys[start] == pattern[0] && keys[start + 1] == pattern[1] {
                syllable.final_c = vec![start, start + 1];
                return;
            }
        }
    }

    // Try 1-char finals
    if remaining >= 1 && constants::VALID_FINALS_1.contains(&keys[start]) {
        syllable.final_c = vec![start];
    }
}

/// Check if first vowel is a glide (√¢m ƒë·ªám)
///
/// Glide patterns:
/// - o + (a, ƒÉ, e) ‚Üí oa, oƒÉ, oe
/// - u + (a, √¢, √™, y) after "qu" ‚Üí qua, qu√¢, qu√™, quy
fn is_glide_pattern(first: u16, second: u16, syllable: &Syllable) -> bool {
    // Check if initial is "qu" - then u is part of initial, not glide
    let is_qu = syllable.initial.len() == 2;
    if is_qu {
        // qu already includes u, no separate glide
        return false;
    }

    match first {
        keys::O => {
            // o + (a, e) ‚Üí glide
            matches!(second, keys::A | keys::E)
        }
        keys::U => {
            // u + (a, √¢, √™, y) when NOT after qu
            // Actually u is glide in: uy, ua (non-qu context handled differently)
            matches!(second, keys::Y | keys::E)
        }
        _ => false,
    }
}

/// Check if buffer represents a potentially valid Vietnamese syllable structure
///
/// This is a quick structural check, not full phonological validation
pub fn is_valid_structure(buffer_keys: &[u16]) -> bool {
    if buffer_keys.is_empty() {
        return false;
    }

    let syllable = parse(buffer_keys);

    // Must have at least one vowel
    if syllable.is_empty() {
        return false;
    }

    // Basic structure check passed
    true
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::keys_from_str;

    #[test]
    fn parse_simple_syllable() {
        let s = parse(&keys_from_str("ba"));
        assert_eq!(s.initial.len(), 1);
        assert_eq!(s.vowel.len(), 1);
        assert!(s.final_c.is_empty());
    }

    #[test]
    fn parse_ngh_initial() {
        let s = parse(&keys_from_str("nghieng"));
        assert_eq!(s.initial.len(), 3);
        assert_eq!(s.vowel.len(), 2);
        assert_eq!(s.final_c.len(), 2);
    }

    #[test]
    fn parse_qu_initial() {
        let s = parse(&keys_from_str("qua"));
        assert_eq!(s.initial.len(), 2);
        assert_eq!(s.vowel.len(), 1);
        assert!(s.glide.is_none());
    }

    #[test]
    fn parse_hoa_with_glide() {
        let s = parse(&keys_from_str("hoa"));
        assert_eq!(s.initial.len(), 1);
        assert!(s.glide.is_some());
        assert_eq!(s.vowel.len(), 1);
    }

    #[test]
    fn parse_gi_initial() {
        let s = parse(&keys_from_str("giau"));
        assert_eq!(s.initial.len(), 2);
        assert_eq!(s.vowel.len(), 2);
    }

    #[test]
    fn parse_duoc() {
        let s = parse(&keys_from_str("duoc"));
        assert_eq!(s.initial.len(), 1);
        assert_eq!(s.vowel.len(), 2);
        assert_eq!(s.final_c.len(), 1);
    }

    #[test]
    fn parse_vowel_only() {
        let s = parse(&keys_from_str("a"));
        assert!(s.initial.is_empty());
        assert_eq!(s.vowel.len(), 1);
    }

    #[test]
    fn invalid_no_vowel() {
        let s = parse(&keys_from_str("bcd"));
        assert!(s.is_empty());
    }

    #[test]
    fn test_is_valid_structure() {
        assert!(is_valid_structure(&keys_from_str("ba")));
        assert!(is_valid_structure(&keys_from_str("nghieng")));
        assert!(is_valid_structure(&keys_from_str("a")));
        assert!(!is_valid_structure(&keys_from_str("bcd")));
        assert!(!is_valid_structure(&keys_from_str("")));
    }
}
</file>

<file path="core/src/engine/validation.rs">
//! Vietnamese Syllable Validation
//!
//! Rule-based validation for Vietnamese syllables.
//! Each rule is a simple function that returns Some(error) if invalid, None if OK.

use super::syllable::{parse, Syllable};
use crate::data::constants;
use crate::data::keys;

/// Validation result
#[derive(Debug, Clone, PartialEq)]
pub enum ValidationResult {
    Valid,
    InvalidInitial,
    InvalidFinal,
    InvalidSpelling,
    NoVowel,
}

impl ValidationResult {
    pub fn is_valid(&self) -> bool {
        matches!(self, ValidationResult::Valid)
    }
}

// =============================================================================
// VALIDATION RULES - Each rule is a simple check function
// =============================================================================

/// Rule type: takes buffer keys and parsed syllable, returns error or None
type Rule = fn(&[u16], &Syllable) -> Option<ValidationResult>;

/// All validation rules in order of priority
const RULES: &[Rule] = &[
    rule_has_vowel,
    rule_valid_initial,
    rule_all_chars_parsed,
    rule_spelling,
    rule_valid_final,
];

// =============================================================================
// RULE IMPLEMENTATIONS
// =============================================================================

/// Rule 1: Must have at least one vowel
fn rule_has_vowel(_keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.is_empty() {
        return Some(ValidationResult::NoVowel);
    }
    None
}

/// Rule 2: Initial consonant must be valid Vietnamese
fn rule_valid_initial(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.initial.is_empty() {
        return None; // No initial = starts with vowel, OK
    }

    let initial: Vec<u16> = syllable.initial.iter().map(|&i| keys[i]).collect();

    let is_valid = match initial.len() {
        1 => constants::VALID_INITIALS_1.contains(&initial[0]),
        2 => constants::VALID_INITIALS_2
            .iter()
            .any(|p| p[0] == initial[0] && p[1] == initial[1]),
        3 => initial[0] == keys::N && initial[1] == keys::G && initial[2] == keys::H,
        _ => false,
    };

    if !is_valid {
        return Some(ValidationResult::InvalidInitial);
    }
    None
}

/// Rule 3: All characters must be parsed into syllable structure
fn rule_all_chars_parsed(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    let parsed = syllable.initial.len()
        + syllable.glide.map_or(0, |_| 1)
        + syllable.vowel.len()
        + syllable.final_c.len();

    if parsed != keys.len() {
        return Some(ValidationResult::InvalidFinal);
    }
    None
}

/// Rule 4: Vietnamese spelling rules (c/k, g/gh, ng/ngh)
fn rule_spelling(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.initial.is_empty() || syllable.vowel.is_empty() {
        return None;
    }

    let initial: Vec<u16> = syllable.initial.iter().map(|&i| keys[i]).collect();
    let first_vowel = keys[syllable.glide.unwrap_or(syllable.vowel[0])];

    // Check all spelling rules
    for &(consonant, vowels, _msg) in constants::SPELLING_RULES {
        if initial == consonant && vowels.contains(&first_vowel) {
            return Some(ValidationResult::InvalidSpelling);
        }
    }

    None
}

/// Rule 5: Final consonant must be valid
fn rule_valid_final(keys: &[u16], syllable: &Syllable) -> Option<ValidationResult> {
    if syllable.final_c.is_empty() {
        return None;
    }

    let final_c: Vec<u16> = syllable.final_c.iter().map(|&i| keys[i]).collect();

    let is_valid = match final_c.len() {
        1 => constants::VALID_FINALS_1.contains(&final_c[0]),
        2 => constants::VALID_FINALS_2
            .iter()
            .any(|p| p[0] == final_c[0] && p[1] == final_c[1]),
        _ => false,
    };

    if !is_valid {
        return Some(ValidationResult::InvalidFinal);
    }
    None
}

// =============================================================================
// PUBLIC API
// =============================================================================

/// Validate buffer as Vietnamese syllable - runs all rules
pub fn validate(buffer_keys: &[u16]) -> ValidationResult {
    if buffer_keys.is_empty() {
        return ValidationResult::NoVowel;
    }

    let syllable = parse(buffer_keys);

    // Run all rules in order
    for rule in RULES {
        if let Some(error) = rule(buffer_keys, &syllable) {
            return error;
        }
    }

    ValidationResult::Valid
}

/// Quick check if buffer could be valid Vietnamese
pub fn is_valid(buffer_keys: &[u16]) -> bool {
    validate(buffer_keys).is_valid()
}

// =============================================================================
// TESTS
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::keys_from_str;

    /// Valid Vietnamese syllables
    const VALID: &[&str] = &[
        "ba", "ca", "an", "em", "gi", "gia", "giau", "ke", "ki", "ky", "nghe", "nghi", "nghieng",
        "truong", "nguoi", "duoc",
    ];

    /// Invalid: no vowel
    const INVALID_NO_VOWEL: &[&str] = &["bcd", "bcdfgh"];

    /// Invalid: bad initial
    const INVALID_INITIAL: &[&str] = &["clau", "john", "bla", "string", "chrome"];

    /// Invalid: spelling violations
    const INVALID_SPELLING: &[&str] = &["ci", "ce", "cy", "ka", "ko", "ku", "ngi", "nge", "ge"];

    /// Invalid: foreign words
    const INVALID_FOREIGN: &[&str] = &["exp", "expect", "test", "claudeco", "claus"];

    fn assert_all_valid(words: &[&str]) {
        for w in words {
            assert!(is_valid(&keys_from_str(w)), "'{}' should be valid", w);
        }
    }

    fn assert_all_invalid(words: &[&str]) {
        for w in words {
            assert!(!is_valid(&keys_from_str(w)), "'{}' should be invalid", w);
        }
    }

    #[test]
    fn test_valid() {
        assert_all_valid(VALID);
    }

    #[test]
    fn test_invalid_no_vowel() {
        assert_all_invalid(INVALID_NO_VOWEL);
    }

    #[test]
    fn test_invalid_initial() {
        assert_all_invalid(INVALID_INITIAL);
    }

    #[test]
    fn test_invalid_spelling() {
        assert_all_invalid(INVALID_SPELLING);
    }

    #[test]
    fn test_invalid_foreign() {
        assert_all_invalid(INVALID_FOREIGN);
    }
}
</file>

<file path="core/src/lib.rs">
//! G√µ Nhanh Vietnamese IME Core
//!
//! Simple Vietnamese input method engine supporting Telex and VNI.
//!
//! # FFI Usage
//!
//! ```c
//! // Initialize once at app start
//! ime_init();
//! ime_method(0);  // 0=Telex, 1=VNI
//!
//! // Process each keystroke
//! ImeResult* r = ime_key(keycode, is_shift, is_ctrl);
//! if (r && r->action == 1) {
//!     // Send r->backspace deletes, then r->chars
//! }
//! ime_free(r);
//!
//! // Clean up on word boundary
//! ime_clear();
//! ```

pub mod data;
pub mod engine;
pub mod input;
pub mod updater;
pub mod utils;

use engine::{Engine, Result};
use std::sync::Mutex;

// Global engine instance (thread-safe via Mutex)
static ENGINE: Mutex<Option<Engine>> = Mutex::new(None);

// ============================================================
// FFI Interface
// ============================================================

/// Initialize the IME engine.
///
/// Must be called exactly once before any other `ime_*` functions.
/// Thread-safe: uses internal mutex.
///
/// # Panics
/// Panics if mutex is poisoned (only if previous call panicked).
#[no_mangle]
pub extern "C" fn ime_init() {
    let mut guard = ENGINE.lock().unwrap();
    *guard = Some(Engine::new());
}

/// Process a key event and return the result.
///
/// # Arguments
/// * `key` - macOS virtual keycode (0-127 for standard keys)
/// * `caps` - true if Shift or CapsLock is pressed
/// * `ctrl` - true if Cmd/Ctrl/Alt is pressed (bypasses IME)
///
/// # Returns
/// * Pointer to `Result` struct (caller must free with `ime_free`)
/// * `null` if engine not initialized
///
/// # Result struct
/// * `action`: 0=None (pass through), 1=Send (replace text), 2=Restore
/// * `backspace`: number of characters to delete
/// * `chars`: UTF-32 codepoints to insert
/// * `count`: number of valid chars
#[no_mangle]
pub extern "C" fn ime_key(key: u16, caps: bool, ctrl: bool) -> *mut Result {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        let r = e.on_key(key, caps, ctrl);
        Box::into_raw(Box::new(r))
    } else {
        std::ptr::null_mut()
    }
}

/// Set the input method.
///
/// # Arguments
/// * `method` - 0 for Telex, 1 for VNI
///
/// No-op if engine not initialized.
#[no_mangle]
pub extern "C" fn ime_method(method: u8) {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        e.set_method(method);
    }
}

/// Enable or disable the engine.
///
/// When disabled, `ime_key` returns action=0 (pass through).
/// No-op if engine not initialized.
#[no_mangle]
pub extern "C" fn ime_enabled(enabled: bool) {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        e.set_enabled(enabled);
    }
}

/// Clear the input buffer.
///
/// Call on word boundaries (space, punctuation, mouse click, focus change).
/// No-op if engine not initialized.
#[no_mangle]
pub extern "C" fn ime_clear() {
    let mut guard = ENGINE.lock().unwrap();
    if let Some(ref mut e) = *guard {
        e.clear();
    }
}

/// Free a result pointer returned by `ime_key`.
///
/// # Safety
/// * `r` must be a pointer returned by `ime_key`, or null
/// * Must be called exactly once per non-null `ime_key` return
/// * Do not use `r` after calling this function
#[no_mangle]
pub unsafe extern "C" fn ime_free(r: *mut Result) {
    if !r.is_null() {
        drop(Box::from_raw(r));
    }
}

// ============================================================
// Tests
// ============================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::data::keys;

    #[test]
    fn test_ffi_flow() {
        ime_init();
        ime_method(0); // Telex

        // Type 'a' + 's' -> √°
        let r1 = ime_key(keys::A, false, false);
        assert!(!r1.is_null());
        unsafe { ime_free(r1) };

        let r2 = ime_key(keys::S, false, false);
        assert!(!r2.is_null());
        unsafe {
            assert_eq!((*r2).chars[0], '√°' as u32);
            ime_free(r2);
        }

        ime_clear();
    }
}
</file>

<file path="scripts/build-windows.sh">
#!/bin/bash
set -e

# GoNhanh Windows Build Script
# Run on Windows with Git Bash or via CI/CD

# Source rustup environment
if [ -f "$HOME/.cargo/env" ]; then
    source "$HOME/.cargo/env"
fi

# Navigate to project root
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Check if running on Windows
is_windows() {
    [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ -n "$WINDIR" ]]
}

# Parse arguments
CLEAN_INSTALL=false
for arg in "$@"; do
    case $arg in
        --clean)
            CLEAN_INSTALL=true
            shift
            ;;
        --help|-h)
            echo "Usage: build-windows.sh [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  --clean    Remove existing build artifacts before building"
            echo "  --help     Show this help message"
            exit 0
            ;;
    esac
done

# Clean build artifacts
if [ "$CLEAN_INSTALL" = true ]; then
    echo "Cleaning build artifacts..."

    if is_windows; then
        # Kill running GoNhanh processes
        if tasklist 2>/dev/null | grep -qi "GoNhanh.exe"; then
            echo "  Stopping GoNhanh.exe..."
            taskkill //F //IM "GoNhanh.exe" 2>/dev/null || true
            sleep 1
        fi
    fi

    rm -rf "$PROJECT_ROOT/platforms/windows/GoNhanh/bin" 2>/dev/null || true
    rm -rf "$PROJECT_ROOT/platforms/windows/GoNhanh/obj" 2>/dev/null || true
    rm -rf "$PROJECT_ROOT/platforms/windows/publish" 2>/dev/null || true
    rm -rf "$PROJECT_ROOT/core/target" 2>/dev/null || true
    echo "  Done"
    echo ""
fi

# Get version from git tag
GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
VERSION=${GIT_TAG#v}

echo "Building GoNhanh for Windows"
echo "Version: $VERSION"
echo ""

# Check platform
if ! is_windows; then
    echo "Skipped: Not running on Windows"
    echo ""
    echo "This script requires Windows (Git Bash)."
    echo "Use GitHub Actions for CI/CD builds."
    exit 0
fi

# Build Rust core
echo "[1/3] Building Rust core..."
cd "$PROJECT_ROOT/core"
cargo build --release --target x86_64-pc-windows-msvc

mkdir -p "$PROJECT_ROOT/platforms/windows/GoNhanh/Native"
cp "target/x86_64-pc-windows-msvc/release/gonhanh_core.dll" \
   "$PROJECT_ROOT/platforms/windows/GoNhanh/Native/gonhanh_core.dll"
echo "  Output: gonhanh_core.dll"

# Build WPF app
echo "[2/3] Building WPF app..."
cd "$PROJECT_ROOT/platforms/windows/GoNhanh"

if ! command -v dotnet &> /dev/null; then
    echo "Error: .NET SDK not found"
    echo "Install from: https://dotnet.microsoft.com/download"
    exit 1
fi

dotnet publish -c Release -r win-x64 --self-contained false \
    -p:Version="$VERSION" \
    -p:FileVersion="$VERSION" \
    -p:AssemblyVersion="${VERSION%%.*}.0.0.0" \
    -o ../publish \
    -v quiet

echo "  Output: platforms/windows/publish/"

# Create ZIP package
echo "[3/3] Creating package..."
cd "$PROJECT_ROOT/platforms/windows"
ZIP_NAME="GoNhanh-${VERSION}-win-x64.zip"
rm -f "$ZIP_NAME" 2>/dev/null || true

if command -v zip &> /dev/null; then
    zip -rq "$ZIP_NAME" publish/*
elif command -v 7z &> /dev/null; then
    7z a -bso0 "$ZIP_NAME" publish/*
else
    echo "  Warning: zip/7z not found, skipping package"
    ZIP_NAME=""
fi

if [ -n "$ZIP_NAME" ]; then
    echo "  Output: $ZIP_NAME"
fi

echo ""
echo "Build complete!"
</file>

<file path="platforms/macos/AppMetadata.swift">
import Foundation
import AppKit

// MARK: - App Metadata (Centralized)
// All project metadata in one place for consistency

enum AppMetadata {
    static let name = "G√µ Nhanh"

    // App Logo - d√πng chung cho m·ªçi n∆°i
    static var logo: NSImage {
        NSImage(named: "AppLogo") ?? NSApp.applicationIconImage ?? NSImage()
    }
    static let displayName = "G√µ Nhanh"
    static let tagline = "B·ªô g√µ ti·∫øng Vi·ªát hi·ªáu su·∫•t cao"
    static let version = Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "1.0.0"
    static let buildNumber = Bundle.main.infoDictionary?["CFBundleVersion"] as? String ?? "1"

    // Author
    static let author = "Kha Phan"
    static let authorEmail = "nhatkha1407@gmail.com"

    // Links
    static let website = "https://gonhanh.org"
    static let repository = "https://github.com/khaphanspace/gonhanh.org"
    static let issuesURL = "https://github.com/khaphanspace/gonhanh.org/issues"
    static let authorLinkedin = "https://www.linkedin.com/in/khaphanspace"

    // Legal
    static let copyright = "Copyright ¬© 2025 \(author). All rights reserved."
    static let license = "GPL-3.0-or-later"

    // Tech
    static let techStack = "Rust + SwiftUI"

    // Credits for About panel
    static var credits: String {
        """
        \(tagline)

        T√°c gi·∫£: \(author)

        Made with Rust + SwiftUI
        """
    }

    // Full about text
    static var aboutText: String {
        """
        \(displayName) v\(version)

        \(tagline)

        T√°c gi·∫£: \(author)
        Website: \(website)
        GitHub: \(repository)

        \(copyright)
        License: \(license)
        """
    }
}

// MARK: - Settings Keys (Shared)

enum SettingsKey {
    static let enabled = "gonhanh.enabled"
    static let method = "gonhanh.method"
    static let hasCompletedOnboarding = "gonhanh.onboarding.completed"
    static let permissionGranted = "gonhanh.permission.granted"
}

// MARK: - Input Mode

enum InputMode: Int, CaseIterable {
    case telex = 0
    case vni = 1

    var name: String {
        switch self {
        case .telex: return "Telex"
        case .vni: return "VNI"
        }
    }

    var shortName: String {
        switch self {
        case .telex: return "T"
        case .vni: return "V"
        }
    }

    var description: String {
        switch self {
        case .telex: return "aw, ow, w, s, f, r, x, j"
        case .vni: return "a8, o9, 1-5"
        }
    }

    var fullDescription: String {
        switch self {
        case .telex: return "Telex (\(description))"
        case .vni: return "VNI (\(description))"
        }
    }
}
</file>

<file path="core/src/engine/mod.rs">
//! Vietnamese IME Engine
//!
//! Core engine for Vietnamese input method processing.
//! Uses pattern-based transformation with validation-first approach.
//!
//! ## Architecture
//!
//! 1. **Validation First**: Check if buffer is valid Vietnamese before transforming
//! 2. **Pattern-Based**: Scan entire buffer for patterns instead of case-by-case
//! 3. **Shortcut Support**: User-defined abbreviations with priority
//! 4. **Longest-Match-First**: For diacritic placement

pub mod buffer;
pub mod shortcut;
pub mod syllable;
pub mod transform;
pub mod validation;

use crate::data::{
    chars::{self, mark, tone},
    keys,
    vowel::{Phonology, Vowel},
};
use crate::input::{self, ToneType};
use crate::utils;
use buffer::{Buffer, Char, MAX};
use shortcut::{InputMethod, ShortcutTable};
use validation::is_valid;

/// Engine action result
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Action {
    None = 0,
    Send = 1,
    Restore = 2,
}

/// Result for FFI
#[repr(C)]
pub struct Result {
    pub chars: [u32; MAX],
    pub action: u8,
    pub backspace: u8,
    pub count: u8,
    pub _pad: u8,
}

impl Result {
    pub fn none() -> Self {
        Self {
            chars: [0; MAX],
            action: Action::None as u8,
            backspace: 0,
            count: 0,
            _pad: 0,
        }
    }

    pub fn send(backspace: u8, chars: &[char]) -> Self {
        let mut result = Self {
            chars: [0; MAX],
            action: Action::Send as u8,
            backspace,
            count: chars.len().min(MAX) as u8,
            _pad: 0,
        };
        for (i, &c) in chars.iter().take(MAX).enumerate() {
            result.chars[i] = c as u32;
        }
        result
    }
}

/// Transform type for revert tracking
#[derive(Clone, Copy, Debug, PartialEq)]
enum Transform {
    Mark(u16, u8),
    Tone(u16, u8),
    Stroke(u16),
    /// W as vowel ∆∞ (for revert: ww ‚Üí ww)
    WAsVowel,
}

/// Main Vietnamese IME engine
pub struct Engine {
    buf: Buffer,
    method: u8,
    enabled: bool,
    last_transform: Option<Transform>,
    shortcuts: ShortcutTable,
}

impl Default for Engine {
    fn default() -> Self {
        Self::new()
    }
}

impl Engine {
    pub fn new() -> Self {
        Self {
            buf: Buffer::new(),
            method: 0,
            enabled: true,
            last_transform: None,
            shortcuts: ShortcutTable::with_defaults(),
        }
    }

    pub fn set_method(&mut self, method: u8) {
        self.method = method;
    }

    pub fn set_enabled(&mut self, enabled: bool) {
        self.enabled = enabled;
        if !enabled {
            self.buf.clear();
        }
    }

    pub fn shortcuts_mut(&mut self) -> &mut ShortcutTable {
        &mut self.shortcuts
    }

    /// Get current input method as InputMethod enum
    fn current_input_method(&self) -> InputMethod {
        match self.method {
            0 => InputMethod::Telex,
            1 => InputMethod::Vni,
            _ => InputMethod::All,
        }
    }

    /// Handle key event - main entry point
    pub fn on_key(&mut self, key: u16, caps: bool, ctrl: bool) -> Result {
        if !self.enabled || ctrl {
            self.buf.clear();
            self.last_transform = None;
            return Result::none();
        }

        // Check for word boundary shortcuts BEFORE clearing buffer
        if keys::is_break(key) {
            let result = self.try_word_boundary_shortcut();
            self.buf.clear();
            self.last_transform = None;
            return result;
        }

        if key == keys::DELETE {
            self.buf.pop();
            self.last_transform = None;
            return Result::none();
        }

        self.process(key, caps)
    }

    /// Main processing pipeline - pattern-based
    fn process(&mut self, key: u16, caps: bool) -> Result {
        let m = input::get(self.method);

        // Check modifiers by scanning buffer for patterns

        // 1. Stroke modifier (d ‚Üí ƒë)
        if m.stroke(key) {
            if let Some(result) = self.try_stroke(key) {
                return result;
            }
        }

        // 2. Tone modifier (circumflex, horn, breve)
        if let Some(tone_type) = m.tone(key) {
            let targets = m.tone_targets(key);
            if let Some(result) = self.try_tone(key, caps, tone_type, targets) {
                return result;
            }
        }

        // 3. Mark modifier
        if let Some(mark_val) = m.mark(key) {
            if let Some(result) = self.try_mark(key, caps, mark_val) {
                return result;
            }
        }

        // 4. Remove modifier
        if m.remove(key) {
            self.last_transform = None;
            return self.handle_remove();
        }

        // 5. In Telex: "w" as vowel "∆∞" when valid Vietnamese context
        // Examples: "w" ‚Üí "∆∞", "nhw" ‚Üí "nh∆∞", but "kw" ‚Üí "kw" (invalid)
        if self.method == 0 && key == keys::W {
            if let Some(result) = self.try_w_as_vowel(caps) {
                return result;
            }
        }

        // Not a modifier - normal letter
        self.handle_normal_letter(key, caps)
    }

    /// Try word boundary shortcuts (triggered by space, punctuation, etc.)
    fn try_word_boundary_shortcut(&mut self) -> Result {
        if self.buf.is_empty() {
            return Result::none();
        }

        let buffer_str = self.buf.to_string_preserve_case();
        let input_method = self.current_input_method();

        // Check for word boundary shortcut match
        if let Some(m) =
            self.shortcuts
                .try_match_for_method(&buffer_str, Some(' '), true, input_method)
        {
            let output: Vec<char> = m.output.chars().collect();
            return Result::send(m.backspace_count as u8, &output);
        }

        Result::none()
    }

    /// Try "w" as vowel "∆∞" in Telex mode
    ///
    /// Rules:
    /// - "w" alone ‚Üí "∆∞"
    /// - "nhw" ‚Üí "nh∆∞" (valid consonant + ∆∞)
    /// - "kw" ‚Üí "kw" (invalid, k cannot precede ∆∞)
    /// - "ww" ‚Üí revert to "ww"
    fn try_w_as_vowel(&mut self, caps: bool) -> Option<Result> {
        // Check revert: ww ‚Üí ww
        if let Some(Transform::WAsVowel) = self.last_transform {
            self.last_transform = None;
            // Revert: backspace "∆∞", output "ww"
            let w = if caps { 'W' } else { 'w' };
            return Some(Result::send(1, &[w, w]));
        }

        // Try adding U (∆∞ base) to buffer and validate
        self.buf.push(Char::new(keys::U, caps));

        // Set horn tone to make it ∆∞
        if let Some(c) = self.buf.get_mut(self.buf.len() - 1) {
            c.tone = tone::HORN;
        }

        // Validate: is this valid Vietnamese?
        let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
        if is_valid(&buffer_keys) {
            // Valid! Output from the position of ∆∞
            let pos = self.buf.len() - 1;
            self.last_transform = Some(Transform::WAsVowel);
            return Some(self.rebuild_from(pos));
        }

        // Invalid - remove the U we added
        self.buf.pop();
        None
    }

    /// Try to apply stroke transformation by scanning buffer
    fn try_stroke(&mut self, key: u16) -> Option<Result> {
        // Scan buffer for un-stroked 'd'
        let d_pos = self
            .buf
            .iter()
            .enumerate()
            .find(|(_, c)| c.key == keys::D && !c.stroke)
            .map(|(i, _)| i);

        if let Some(pos) = d_pos {
            // Check revert: if last transform was stroke on same key at same position
            if let Some(Transform::Stroke(last_key)) = self.last_transform {
                if last_key == key {
                    return Some(self.revert_stroke(key, pos));
                }
            }

            // Validate buffer before applying stroke
            // Only validate if buffer has vowels (complete syllable)
            // Allow stroke on initial consonant before vowel is typed (e.g., "dd" ‚Üí "ƒë" then "ƒëi")
            let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
            let has_vowel = buffer_keys.iter().any(|&k| keys::is_vowel(k));
            if has_vowel && !is_valid(&buffer_keys) {
                return None;
            }

            // Mark as stroked
            if let Some(c) = self.buf.get_mut(pos) {
                c.stroke = true;
            }

            self.last_transform = Some(Transform::Stroke(key));
            return Some(self.rebuild_from(pos));
        }

        None
    }

    /// Try to apply tone transformation by scanning buffer for targets
    fn try_tone(
        &mut self,
        key: u16,
        caps: bool,
        tone_type: ToneType,
        targets: &[u16],
    ) -> Option<Result> {
        if self.buf.is_empty() {
            return None;
        }

        // Check revert first
        if let Some(Transform::Tone(last_key, _)) = self.last_transform {
            if last_key == key {
                return Some(self.revert_tone(key, caps));
            }
        }

        // Validate buffer
        let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
        if !is_valid(&buffer_keys) {
            return None;
        }

        let tone_val = tone_type.value();

        // Scan buffer for eligible target vowels (without existing tone)
        let mut target_positions = Vec::new();

        // Special case: uo compound for horn
        if tone_type == ToneType::Horn && self.has_uo_compound() {
            for (i, c) in self.buf.iter().enumerate() {
                if (c.key == keys::U || c.key == keys::O) && c.tone == tone::NONE {
                    target_positions.push(i);
                }
            }
        }

        // Normal case: find last matching target
        if target_positions.is_empty() {
            for (i, c) in self.buf.iter().enumerate().rev() {
                if targets.contains(&c.key) && c.tone == tone::NONE {
                    target_positions.push(i);
                    break;
                }
            }
        }

        if target_positions.is_empty() {
            return None;
        }

        // Apply tone
        let mut earliest_pos = usize::MAX;
        for &pos in &target_positions {
            if let Some(c) = self.buf.get_mut(pos) {
                c.tone = tone_val;
                earliest_pos = earliest_pos.min(pos);
            }
        }

        self.last_transform = Some(Transform::Tone(key, tone_val));

        // Reposition mark if needed
        let mark_moved_from = self.reposition_mark_if_needed();
        let mut rebuild_pos = earliest_pos;
        if let Some(old_pos) = mark_moved_from {
            rebuild_pos = rebuild_pos.min(old_pos);
        }

        Some(self.rebuild_from(rebuild_pos))
    }

    /// Try to apply mark transformation
    fn try_mark(&mut self, key: u16, caps: bool, mark_val: u8) -> Option<Result> {
        if self.buf.is_empty() {
            return None;
        }

        // Check revert first
        if let Some(Transform::Mark(last_key, _)) = self.last_transform {
            if last_key == key {
                return Some(self.revert_mark(key, caps));
            }
        }

        // Validate buffer
        let buffer_keys: Vec<u16> = self.buf.iter().map(|c| c.key).collect();
        if !is_valid(&buffer_keys) {
            return None;
        }

        let vowels = self.collect_vowels();
        if vowels.is_empty() {
            return None;
        }

        // Find mark position using phonology rules
        let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
        let has_final = self.has_final_consonant(last_vowel_pos);
        let has_qu = self.has_qu_initial();
        let pos = Phonology::find_tone_position(&vowels, has_final, true, has_qu);

        if let Some(c) = self.buf.get_mut(pos) {
            c.mark = mark_val;
            self.last_transform = Some(Transform::Mark(key, mark_val));
            return Some(self.rebuild_from(pos));
        }

        None
    }

    /// Check for uo compound in buffer
    fn has_uo_compound(&self) -> bool {
        let mut prev_key: Option<u16> = None;
        for c in self.buf.iter() {
            if keys::is_vowel(c.key) {
                if let Some(pk) = prev_key {
                    if (pk == keys::U && c.key == keys::O) || (pk == keys::O && c.key == keys::U) {
                        return true;
                    }
                }
                prev_key = Some(c.key);
            } else {
                prev_key = None;
            }
        }
        false
    }

    /// Reposition mark after tone change
    fn reposition_mark_if_needed(&mut self) -> Option<usize> {
        let mark_info: Option<(usize, u8)> = self
            .buf
            .iter()
            .enumerate()
            .find(|(_, c)| c.mark > 0)
            .map(|(i, c)| (i, c.mark));

        if let Some((old_pos, mark_value)) = mark_info {
            let vowels = self.collect_vowels();
            if vowels.is_empty() {
                return None;
            }

            let last_vowel_pos = vowels.last().map(|v| v.pos).unwrap_or(0);
            let has_final = self.has_final_consonant(last_vowel_pos);
            let has_qu = self.has_qu_initial();
            let new_pos = Phonology::find_tone_position(&vowels, has_final, true, has_qu);

            if new_pos != old_pos {
                if let Some(c) = self.buf.get_mut(old_pos) {
                    c.mark = 0;
                }
                if let Some(c) = self.buf.get_mut(new_pos) {
                    c.mark = mark_value;
                }
                return Some(old_pos);
            }
        }
        None
    }

    /// Common revert logic: clear modifier, add key to buffer, rebuild output
    fn revert_and_rebuild(&mut self, pos: usize, key: u16, caps: bool) -> Result {
        // Calculate backspace BEFORE adding key (based on old buffer state)
        let backspace = (self.buf.len() - pos) as u8;

        // Add the reverted key to buffer so validation sees the full sequence
        self.buf.push(Char::new(key, caps));

        // Build output from position (includes new key)
        let output: Vec<char> = (pos..self.buf.len())
            .filter_map(|i| self.buf.get(i))
            .filter_map(|c| utils::key_to_char(c.key, c.caps))
            .collect();

        Result::send(backspace, &output)
    }

    /// Revert tone transformation
    fn revert_tone(&mut self, key: u16, caps: bool) -> Result {
        self.last_transform = None;

        for pos in self.buf.find_vowels().into_iter().rev() {
            if let Some(c) = self.buf.get_mut(pos) {
                if c.tone > tone::NONE {
                    c.tone = tone::NONE;
                    return self.revert_and_rebuild(pos, key, caps);
                }
            }
        }
        Result::none()
    }

    /// Revert mark transformation
    fn revert_mark(&mut self, key: u16, caps: bool) -> Result {
        self.last_transform = None;

        for pos in self.buf.find_vowels().into_iter().rev() {
            if let Some(c) = self.buf.get_mut(pos) {
                if c.mark > mark::NONE {
                    c.mark = mark::NONE;
                    return self.revert_and_rebuild(pos, key, caps);
                }
            }
        }
        Result::none()
    }

    /// Revert stroke transformation at specific position
    fn revert_stroke(&mut self, key: u16, pos: usize) -> Result {
        self.last_transform = None;

        if let Some(c) = self.buf.get_mut(pos) {
            if c.key == keys::D && !c.stroke {
                // Un-stroked d found at pos - this means we need to add another d
                let caps = c.caps;
                self.buf.push(Char::new(key, caps));
                return self.rebuild_from(pos);
            }
        }
        Result::none()
    }

    /// Handle remove modifier
    fn handle_remove(&mut self) -> Result {
        for pos in self.buf.find_vowels().into_iter().rev() {
            if let Some(c) = self.buf.get_mut(pos) {
                if c.mark > mark::NONE {
                    c.mark = mark::NONE;
                    return self.rebuild_from(pos);
                }
                if c.tone > tone::NONE {
                    c.tone = tone::NONE;
                    return self.rebuild_from(pos);
                }
            }
        }
        Result::none()
    }

    /// Handle normal letter input
    fn handle_normal_letter(&mut self, key: u16, caps: bool) -> Result {
        self.last_transform = None;
        if keys::is_letter(key) {
            self.buf.push(Char::new(key, caps));
        } else {
            self.buf.clear();
        }
        Result::none()
    }

    /// Collect vowels from buffer
    fn collect_vowels(&self) -> Vec<Vowel> {
        utils::collect_vowels(&self.buf)
    }

    /// Check for final consonant after position
    fn has_final_consonant(&self, after_pos: usize) -> bool {
        utils::has_final_consonant(&self.buf, after_pos)
    }

    /// Check for qu initial
    fn has_qu_initial(&self) -> bool {
        utils::has_qu_initial(&self.buf)
    }

    /// Rebuild output from position
    fn rebuild_from(&self, from: usize) -> Result {
        let mut output = Vec::with_capacity(self.buf.len() - from);
        let mut backspace = 0u8;

        for i in from..self.buf.len() {
            if let Some(c) = self.buf.get(i) {
                backspace += 1;

                if c.key == keys::D && c.stroke {
                    output.push(chars::get_d(c.caps));
                } else if let Some(ch) = chars::to_char(c.key, c.caps, c.tone, c.mark) {
                    output.push(ch);
                } else if let Some(ch) = utils::key_to_char(c.key, c.caps) {
                    output.push(ch);
                }
            }
        }

        if output.is_empty() {
            Result::none()
        } else {
            Result::send(backspace, &output)
        }
    }

    /// Clear buffer
    pub fn clear(&mut self) {
        self.buf.clear();
        self.last_transform = None;
    }
}

#[cfg(test)]
mod tests {
    use crate::utils::{telex, vni};

    const TELEX_BASIC: &[(&str, &str)] = &[
        ("as", "√°"),
        ("af", "√†"),
        ("ar", "·∫£"),
        ("ax", "√£"),
        ("aj", "·∫°"),
        ("aa", "√¢"),
        ("aw", "ƒÉ"),
        ("ee", "√™"),
        ("oo", "√¥"),
        ("ow", "∆°"),
        ("uw", "∆∞"),
        ("dd", "ƒë"),
    ];

    const VNI_BASIC: &[(&str, &str)] = &[
        ("a1", "√°"),
        ("a2", "√†"),
        ("a3", "·∫£"),
        ("a4", "√£"),
        ("a5", "·∫°"),
        ("a6", "√¢"),
        ("a8", "ƒÉ"),
        ("e6", "√™"),
        ("o6", "√¥"),
        ("o7", "∆°"),
        ("u7", "∆∞"),
        ("d9", "ƒë"),
    ];

    const TELEX_COMPOUND: &[(&str, &str)] =
        &[("duocw", "d∆∞∆°c"), ("nguoiw", "ng∆∞∆°i"), ("tuoiws", "t∆∞·ªõi")];

    #[test]
    fn test_telex_basic() {
        telex(TELEX_BASIC);
    }

    #[test]
    fn test_vni_basic() {
        vni(VNI_BASIC);
    }

    #[test]
    fn test_telex_compound() {
        telex(TELEX_COMPOUND);
    }
}
</file>

<file path="core/src/engine/shortcut.rs">
//! Shortcut Table - Abbreviation expansion
//!
//! Allows users to define shortcuts like "vn" ‚Üí "Vi·ªát Nam"
//! Shortcuts can be specific to input methods (Telex/VNI) or apply to all.

use std::collections::HashMap;

/// Input method that shortcut applies to
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub enum InputMethod {
    /// Apply to all input methods
    #[default]
    All,
    /// Apply only to Telex
    Telex,
    /// Apply only to VNI
    Vni,
}

/// Trigger condition for shortcut
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TriggerCondition {
    /// Trigger immediately when buffer matches
    Immediate,
    /// Trigger when word boundary (space, punctuation) is pressed
    OnWordBoundary,
}

/// Case handling mode
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum CaseMode {
    /// Keep replacement exactly as defined
    Exact,
    /// Match case of trigger: "VN" ‚Üí "VI·ªÜT NAM", "vn" ‚Üí "Vi·ªát Nam"
    MatchCase,
}

/// A single shortcut entry
#[derive(Debug, Clone)]
pub struct Shortcut {
    /// Trigger string (lowercase for matching)
    pub trigger: String,
    /// Replacement text
    pub replacement: String,
    /// When to trigger
    pub condition: TriggerCondition,
    /// How to handle case
    pub case_mode: CaseMode,
    /// Whether this shortcut is enabled
    pub enabled: bool,
    /// Which input method this shortcut applies to
    pub input_method: InputMethod,
}

impl Shortcut {
    /// Create a new shortcut with word boundary trigger (applies to all input methods)
    pub fn new(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::OnWordBoundary,
            case_mode: CaseMode::MatchCase,
            enabled: true,
            input_method: InputMethod::All,
        }
    }

    /// Create an immediate trigger shortcut (applies to all input methods)
    pub fn immediate(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::Immediate,
            case_mode: CaseMode::Exact,
            enabled: true,
            input_method: InputMethod::All,
        }
    }

    /// Create a Telex-specific shortcut with immediate trigger
    pub fn telex(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::Immediate,
            case_mode: CaseMode::Exact,
            enabled: true,
            input_method: InputMethod::Telex,
        }
    }

    /// Create a VNI-specific shortcut with immediate trigger
    pub fn vni(trigger: &str, replacement: &str) -> Self {
        Self {
            trigger: trigger.to_lowercase(),
            replacement: replacement.to_string(),
            condition: TriggerCondition::Immediate,
            case_mode: CaseMode::Exact,
            enabled: true,
            input_method: InputMethod::Vni,
        }
    }

    /// Set the input method for this shortcut
    pub fn for_method(mut self, method: InputMethod) -> Self {
        self.input_method = method;
        self
    }

    /// Check if shortcut applies to given input method
    ///
    /// - If shortcut is for `All`: matches any method
    /// - If shortcut is for `Telex`: matches `Telex` or `All` query
    /// - If shortcut is for `Vni`: matches `Vni` or `All` query
    pub fn applies_to(&self, query_method: InputMethod) -> bool {
        match self.input_method {
            // Shortcut for All ‚Üí matches any query
            InputMethod::All => true,
            // Shortcut for specific method ‚Üí matches if query is same method OR query is All
            InputMethod::Telex => {
                query_method == InputMethod::Telex || query_method == InputMethod::All
            }
            InputMethod::Vni => {
                query_method == InputMethod::Vni || query_method == InputMethod::All
            }
        }
    }
}

/// Shortcut match result
#[derive(Debug)]
pub struct ShortcutMatch {
    /// Number of characters to backspace
    pub backspace_count: usize,
    /// Replacement text to output
    pub output: String,
    /// Whether to include the trigger key in output
    pub include_trigger_key: bool,
}

/// Shortcut table manager
#[derive(Debug, Default)]
pub struct ShortcutTable {
    /// Shortcuts indexed by trigger (lowercase)
    shortcuts: HashMap<String, Shortcut>,
    /// Sorted triggers by length (longest first) for matching
    sorted_triggers: Vec<String>,
}

impl ShortcutTable {
    pub fn new() -> Self {
        Self {
            shortcuts: HashMap::new(),
            sorted_triggers: vec![],
        }
    }

    /// Create with default Vietnamese shortcuts (common abbreviations)
    ///
    /// Note: "w" ‚Üí "∆∞" is NOT a shortcut, it's handled by the engine
    /// as a vowel key with Vietnamese validation.
    pub fn with_defaults() -> Self {
        let mut table = Self::new();

        // Common abbreviations (apply to all input methods)
        // These trigger on word boundary (space, punctuation)
        table.add(Shortcut::new("vn", "Vi·ªát Nam"));
        table.add(Shortcut::new("hcm", "H·ªì Ch√≠ Minh"));
        table.add(Shortcut::new("hn", "H√† N·ªôi"));
        table.add(Shortcut::new("dc", "ƒë∆∞·ª£c"));
        table.add(Shortcut::new("ko", "kh√¥ng"));

        table
    }

    /// Create with Telex defaults only
    pub fn with_telex_defaults() -> Self {
        // No Telex-specific shortcuts
        // "w" ‚Üí "∆∞" is handled by the engine, not shortcuts
        Self::new()
    }

    /// Create with VNI defaults only
    pub fn with_vni_defaults() -> Self {
        Self::new()
    }

    /// Create with all defaults (common abbreviations)
    pub fn with_all_defaults() -> Self {
        let mut table = Self::new();

        // Common abbreviations (apply to all input methods)
        table.add(Shortcut::new("vn", "Vi·ªát Nam"));
        table.add(Shortcut::new("hcm", "H·ªì Ch√≠ Minh"));
        table.add(Shortcut::new("hn", "H√† N·ªôi"));
        table.add(Shortcut::new("dc", "ƒë∆∞·ª£c"));
        table.add(Shortcut::new("ko", "kh√¥ng"));

        table
    }

    /// Add a shortcut
    pub fn add(&mut self, shortcut: Shortcut) {
        let trigger = shortcut.trigger.clone();
        self.shortcuts.insert(trigger.clone(), shortcut);
        self.rebuild_sorted_triggers();
    }

    /// Remove a shortcut
    pub fn remove(&mut self, trigger: &str) -> Option<Shortcut> {
        let result = self.shortcuts.remove(&trigger.to_lowercase());
        if result.is_some() {
            self.rebuild_sorted_triggers();
        }
        result
    }

    /// Check if buffer matches any shortcut (for any input method)
    ///
    /// Returns (trigger, shortcut) if match found
    pub fn lookup(&self, buffer: &str) -> Option<(&str, &Shortcut)> {
        self.lookup_for_method(buffer, InputMethod::All)
    }

    /// Check if buffer matches any shortcut for specific input method
    ///
    /// Returns (trigger, shortcut) if match found
    pub fn lookup_for_method(
        &self,
        buffer: &str,
        method: InputMethod,
    ) -> Option<(&str, &Shortcut)> {
        let buffer_lower = buffer.to_lowercase();

        // Longest-match-first
        for trigger in &self.sorted_triggers {
            if buffer_lower == *trigger {
                if let Some(shortcut) = self.shortcuts.get(trigger) {
                    if shortcut.enabled && shortcut.applies_to(method) {
                        return Some((trigger, shortcut));
                    }
                }
            }
        }
        None
    }

    /// Try to match buffer with trigger key (for any input method)
    ///
    /// # Arguments
    /// * `buffer` - Current buffer content (as string)
    /// * `key_char` - The key that was just pressed
    /// * `is_word_boundary` - Whether key_char is a word boundary
    ///
    /// # Returns
    /// ShortcutMatch if a shortcut should be triggered
    pub fn try_match(
        &self,
        buffer: &str,
        key_char: Option<char>,
        is_word_boundary: bool,
    ) -> Option<ShortcutMatch> {
        self.try_match_for_method(buffer, key_char, is_word_boundary, InputMethod::All)
    }

    /// Try to match buffer with trigger key for specific input method
    ///
    /// # Arguments
    /// * `buffer` - Current buffer content (as string)
    /// * `key_char` - The key that was just pressed
    /// * `is_word_boundary` - Whether key_char is a word boundary
    /// * `method` - The current input method (Telex/VNI)
    ///
    /// # Returns
    /// ShortcutMatch if a shortcut should be triggered
    pub fn try_match_for_method(
        &self,
        buffer: &str,
        key_char: Option<char>,
        is_word_boundary: bool,
        method: InputMethod,
    ) -> Option<ShortcutMatch> {
        let (trigger, shortcut) = self.lookup_for_method(buffer, method)?;

        match shortcut.condition {
            TriggerCondition::Immediate => {
                let output = self.apply_case(buffer, &shortcut.replacement, shortcut.case_mode);
                Some(ShortcutMatch {
                    backspace_count: trigger.len(),
                    output,
                    include_trigger_key: false,
                })
            }
            TriggerCondition::OnWordBoundary => {
                if is_word_boundary {
                    let mut output =
                        self.apply_case(buffer, &shortcut.replacement, shortcut.case_mode);
                    // Append the trigger key (space, etc.)
                    if let Some(ch) = key_char {
                        output.push(ch);
                    }
                    Some(ShortcutMatch {
                        backspace_count: trigger.len(),
                        output,
                        include_trigger_key: true,
                    })
                } else {
                    None
                }
            }
        }
    }

    /// Apply case transformation based on mode
    fn apply_case(&self, trigger: &str, replacement: &str, mode: CaseMode) -> String {
        match mode {
            CaseMode::Exact => replacement.to_string(),
            CaseMode::MatchCase => {
                if trigger.chars().all(|c| c.is_uppercase()) {
                    // All uppercase ‚Üí replacement all uppercase
                    replacement.to_uppercase()
                } else if trigger
                    .chars()
                    .next()
                    .map(|c| c.is_uppercase())
                    .unwrap_or(false)
                {
                    // First char uppercase ‚Üí capitalize replacement
                    let mut chars = replacement.chars();
                    match chars.next() {
                        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                        None => String::new(),
                    }
                } else {
                    // Lowercase ‚Üí keep replacement as-is
                    replacement.to_string()
                }
            }
        }
    }

    /// Rebuild sorted triggers list (longest first)
    fn rebuild_sorted_triggers(&mut self) {
        self.sorted_triggers = self.shortcuts.keys().cloned().collect();
        self.sorted_triggers
            .sort_by_key(|s| std::cmp::Reverse(s.len()));
    }

    /// Check if shortcut table is empty
    pub fn is_empty(&self) -> bool {
        self.shortcuts.is_empty()
    }

    /// Get number of shortcuts
    pub fn len(&self) -> usize {
        self.shortcuts.len()
    }

    /// Clear all shortcuts
    pub fn clear(&mut self) {
        self.shortcuts.clear();
        self.sorted_triggers.clear();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // Helper: Create table with one word-boundary shortcut
    fn table_with_shortcut(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::new(trigger, replacement));
        table
    }

    // Helper: Create table with one immediate shortcut
    fn table_with_immediate(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::immediate(trigger, replacement));
        table
    }

    // Helper: Create table with Telex-specific shortcut
    fn table_with_telex_shortcut(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::telex(trigger, replacement));
        table
    }

    // Helper: Create table with VNI-specific shortcut
    fn table_with_vni_shortcut(trigger: &str, replacement: &str) -> ShortcutTable {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::vni(trigger, replacement));
        table
    }

    // Helper: Assert shortcut matches and check output/backspace
    fn assert_shortcut_match(
        table: &ShortcutTable,
        buffer: &str,
        key_char: Option<char>,
        is_boundary: bool,
        expected_output: &str,
        expected_backspace: usize,
        method: InputMethod,
    ) {
        let result = table.try_match_for_method(buffer, key_char, is_boundary, method);
        assert!(
            result.is_some(),
            "Shortcut should match for buffer: {}",
            buffer
        );
        let m = result.unwrap();
        assert_eq!(m.output, expected_output);
        assert_eq!(m.backspace_count, expected_backspace);
    }

    // Helper: Assert no shortcut match
    fn assert_no_match(
        table: &ShortcutTable,
        buffer: &str,
        key_char: Option<char>,
        is_boundary: bool,
        method: InputMethod,
    ) {
        let result = table.try_match_for_method(buffer, key_char, is_boundary, method);
        assert!(
            result.is_none(),
            "Shortcut should NOT match for buffer: {}",
            buffer
        );
    }

    #[test]
    fn test_basic_shortcut() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_case_matching() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");

        // Lowercase
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );

        // Uppercase
        assert_shortcut_match(
            &table,
            "VN",
            Some(' '),
            true,
            "VI·ªÜT NAM ",
            2,
            InputMethod::All,
        );

        // Title case
        assert_shortcut_match(
            &table,
            "Vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_immediate_shortcut() {
        let table = table_with_immediate("w", "∆∞");

        // Immediate triggers without word boundary
        let result = table.try_match("w", None, false);
        assert!(result.is_some());
        let m = result.unwrap();
        assert_eq!(m.output, "∆∞");
        assert!(!m.include_trigger_key);
    }

    #[test]
    fn test_word_boundary_required() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");

        // Without word boundary - should not match
        assert_no_match(&table, "vn", Some('a'), false, InputMethod::All);

        // With word boundary - should match
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_longest_match() {
        let mut table = ShortcutTable::new();
        table.add(Shortcut::new("h", "h·ªç"));
        table.add(Shortcut::new("hcm", "H·ªì Ch√≠ Minh"));

        // "hcm" should match the longer shortcut
        let (trigger, _) = table.lookup("hcm").unwrap();
        assert_eq!(trigger, "hcm");
    }

    #[test]
    fn test_disabled_shortcut() {
        let mut table = ShortcutTable::new();
        let mut shortcut = Shortcut::new("vn", "Vi·ªát Nam");
        shortcut.enabled = false;
        table.add(shortcut);

        let result = table.lookup("vn");
        assert!(result.is_none());
    }

    #[test]
    fn test_telex_specific_shortcut() {
        let table = table_with_telex_shortcut("w", "∆∞");

        // Should match for Telex
        assert_shortcut_match(&table, "w", None, false, "∆∞", 1, InputMethod::Telex);

        // Should NOT match for VNI
        assert_no_match(&table, "w", None, false, InputMethod::Vni);

        // Should match for All (fallback)
        assert_shortcut_match(&table, "w", None, false, "∆∞", 1, InputMethod::All);
    }

    #[test]
    fn test_vni_specific_shortcut() {
        let table = table_with_vni_shortcut("7", "∆°");

        // Should match for VNI
        assert_shortcut_match(&table, "7", None, false, "∆°", 1, InputMethod::Vni);

        // Should NOT match for Telex
        assert_no_match(&table, "7", None, false, InputMethod::Telex);
    }

    #[test]
    fn test_all_input_method_shortcut() {
        let table = table_with_shortcut("vn", "Vi·ªát Nam");

        // Should match for Telex
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::Telex,
        );

        // Should match for VNI
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::Vni,
        );

        // Should match for All
        assert_shortcut_match(
            &table,
            "vn",
            Some(' '),
            true,
            "Vi·ªát Nam ",
            2,
            InputMethod::All,
        );
    }

    #[test]
    fn test_with_defaults_has_common_shortcuts() {
        let table = ShortcutTable::with_defaults();

        // "vn" ‚Üí "Vi·ªát Nam" should exist
        let result = table.lookup_for_method("vn", InputMethod::All);
        assert!(result.is_some());

        // "w" is NOT a shortcut anymore (handled by engine)
        let result = table.lookup_for_method("w", InputMethod::Telex);
        assert!(result.is_none());
    }

    #[test]
    fn test_shortcut_for_method_builder() {
        let shortcut = Shortcut::new("test", "Test").for_method(InputMethod::Telex);
        assert_eq!(shortcut.input_method, InputMethod::Telex);

        let shortcut = Shortcut::immediate("x", "y").for_method(InputMethod::Vni);
        assert_eq!(shortcut.input_method, InputMethod::Vni);
    }

    #[test]
    fn test_applies_to() {
        let all_shortcut = Shortcut::new("vn", "Vi·ªát Nam");
        assert!(all_shortcut.applies_to(InputMethod::All));
        assert!(all_shortcut.applies_to(InputMethod::Telex));
        assert!(all_shortcut.applies_to(InputMethod::Vni));

        let telex_shortcut = Shortcut::telex("test", "Test");
        assert!(telex_shortcut.applies_to(InputMethod::All));
        assert!(telex_shortcut.applies_to(InputMethod::Telex));
        assert!(!telex_shortcut.applies_to(InputMethod::Vni));

        let vni_shortcut = Shortcut::vni("7", "∆°");
        assert!(vni_shortcut.applies_to(InputMethod::All));
        assert!(!vni_shortcut.applies_to(InputMethod::Telex));
        assert!(vni_shortcut.applies_to(InputMethod::Vni));
    }
}
</file>

<file path="platforms/macos/AboutView.swift">
import SwiftUI

struct AboutView: View {
    @Environment(\.colorScheme) private var colorScheme

    var body: some View {
        VStack(spacing: 0) {
            header
            Divider()
            infoSection
            Divider()
            linksSection
            Divider()
            footer
        }
        .frame(width: 360)
        .background(colorScheme == .dark ? Color.black.opacity(0.2) : Color.white)
    }

    // MARK: - Header
    private var header: some View {
        VStack(spacing: 8) {
            Image(nsImage: AppMetadata.logo)
                .resizable()
                .frame(width: 80, height: 80)
                .shadow(color: .black.opacity(0.1), radius: 4, y: 2)

            Text(AppMetadata.name)
                .font(.system(size: 24, weight: .bold, design: .rounded))

            Text(AppMetadata.tagline)
                .font(.subheadline)
                .foregroundStyle(.secondary)

            // Version badge
            HStack(spacing: 12) {
                versionBadge(label: "Version", value: AppMetadata.version)
                versionBadge(label: "Build", value: AppMetadata.buildNumber)
            }
            .padding(.top, 4)
        }
        .padding(.vertical, 24)
        .padding(.horizontal, 32)
    }

    private func versionBadge(label: String, value: String) -> some View {
        HStack(spacing: 4) {
            Text(label)
                .font(.caption2)
                .foregroundStyle(.tertiary)
            Text(value)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundStyle(.secondary)
        }
        .padding(.horizontal, 10)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(colorScheme == .dark ? Color.white.opacity(0.08) : Color.black.opacity(0.04))
        )
    }

    // MARK: - Info Section
    private var infoSection: some View {
        VStack(spacing: 12) {
            infoRow(icon: "person.fill", title: "Developer", value: AppMetadata.author)
            infoRow(icon: "envelope.fill", title: "Contact", value: AppMetadata.authorEmail, isLink: true, url: "mailto:\(AppMetadata.authorEmail)")
            infoRow(icon: "hammer.fill", title: "Built with", value: AppMetadata.techStack)
            infoRow(icon: "doc.text.fill", title: "License", value: AppMetadata.license)
        }
        .padding(.vertical, 16)
        .padding(.horizontal, 24)
    }

    private func infoRow(icon: String, title: String, value: String, isLink: Bool = false, url: String? = nil) -> some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.system(size: 12))
                .foregroundStyle(.secondary)
                .frame(width: 20)

            Text(title)
                .font(.callout)
                .foregroundStyle(.secondary)
                .frame(width: 80, alignment: .leading)

            if isLink, let urlString = url, let linkURL = URL(string: urlString) {
                Link(value, destination: linkURL)
                    .font(.callout)
                    .fontWeight(.medium)
            } else {
                Text(value)
                    .font(.callout)
                    .fontWeight(.medium)
                    .foregroundStyle(.primary)
            }

            Spacer()
        }
    }

    // MARK: - Links Section
    private var linksSection: some View {
        HStack(spacing: 16) {
            linkButton(icon: "globe", title: "Website", url: AppMetadata.website)
            linkButton(icon: "chevron.left.forwardslash.chevron.right", title: "GitHub", url: AppMetadata.repository)
            linkButton(icon: "exclamationmark.bubble.fill", title: "Issues", url: AppMetadata.issuesURL)
            linkButton(icon: "link", title: "LinkedIn", url: AppMetadata.authorLinkedin)
        }
        .padding(.vertical, 16)
        .padding(.horizontal, 24)
    }

    private func linkButton(icon: String, title: String, url: String) -> some View {
        Link(destination: URL(string: url)!) {
            VStack(spacing: 6) {
                Image(systemName: icon)
                    .font(.system(size: 16))
                Text(title)
                    .font(.caption2)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 8)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(colorScheme == .dark ? Color.white.opacity(0.06) : Color.black.opacity(0.03))
            )
        }
        .buttonStyle(.plain)
        .foregroundStyle(.secondary)
        .onHover { hovering in
            if hovering {
                NSCursor.pointingHand.push()
            } else {
                NSCursor.pop()
            }
        }
    }

    // MARK: - Footer
    private var footer: some View {
        Text(AppMetadata.copyright)
            .font(.caption2)
            .foregroundStyle(.tertiary)
            .frame(maxWidth: .infinity)
            .padding(.vertical, 12)
            .background(colorScheme == .dark ? Color.white.opacity(0.02) : Color.black.opacity(0.02))
    }
}

#Preview {
    AboutView()
}
</file>

<file path="platforms/macos/OnboardingView.swift">
import SwiftUI

struct OnboardingView: View {
    @Environment(\.colorScheme) private var colorScheme
    @State private var step = 0
    @State private var hasPermission = false
    @State private var selectedMode: InputMode = .telex

    private let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    private var totalSteps: Int { step >= 10 ? 2 : 3 }
    private var stepIndex: Int { step >= 10 ? step - 10 : step }

    var body: some View {
        VStack(spacing: 0) {
            content.frame(height: 320)
            Divider()
            footer
        }
        .frame(width: 440)
        .onAppear {
            hasPermission = AXIsProcessTrusted()
            if UserDefaults.standard.bool(forKey: SettingsKey.permissionGranted) && hasPermission {
                step = 10
            }
        }
        .onReceive(timer) { _ in
            hasPermission = AXIsProcessTrusted()
            if step == 1 && hasPermission { step = 2 }
        }
    }

    @ViewBuilder
    private var content: some View {
        switch step {
        case 0:  WelcomeStep()
        case 1:  PermissionStep()
        case 2:  ReadyStep()
        case 10: SuccessStep()
        case 11: SetupStep(selectedMode: $selectedMode)
        default: EmptyView()
        }
    }

    private var footer: some View {
        HStack {
            HStack(spacing: 6) {
                ForEach(0..<totalSteps, id: \.self) { i in
                    Circle()
                        .fill(i == stepIndex ? Color.accentColor : Color.secondary.opacity(0.3))
                        .frame(width: 6, height: 6)
                }
            }
            Spacer()
            if step == 1 {
                Button("Quay l·∫°i") { step = 0 }
            }
            primaryButton
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 16)
    }

    @ViewBuilder
    private var primaryButton: some View {
        switch step {
        case 0:  Button("Ti·∫øp t·ª•c") { step = 1 }.buttonStyle(.borderedProminent)
        case 1:  Button("M·ªü C√†i ƒë·∫∑t") { openSettings() }.buttonStyle(.borderedProminent)
        case 2:  Button("Kh·ªüi ƒë·ªông l·∫°i") { restart() }.buttonStyle(.borderedProminent)
        case 10: Button("Ti·∫øp t·ª•c") { step = 11 }.buttonStyle(.borderedProminent)
        case 11: Button("Ho√†n t·∫•t") { finish() }.buttonStyle(.borderedProminent)
        default: EmptyView()
        }
    }

    private func openSettings() {
        NSWorkspace.shared.open(URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_Accessibility")!)
    }

    private func restart() {
        UserDefaults.standard.set(selectedMode.rawValue, forKey: SettingsKey.method)
        UserDefaults.standard.set(true, forKey: SettingsKey.permissionGranted)
        UserDefaults.standard.set(false, forKey: SettingsKey.hasCompletedOnboarding)
        let task = Process()
        task.launchPath = "/bin/sh"
        task.arguments = ["-c", "sleep 0.5 && open \"\(Bundle.main.bundlePath)\""]
        try? task.run()
        NSApp.terminate(nil)
    }

    private func finish() {
        UserDefaults.standard.set(selectedMode.rawValue, forKey: SettingsKey.method)
        UserDefaults.standard.set(true, forKey: SettingsKey.hasCompletedOnboarding)
        NotificationCenter.default.post(name: .onboardingCompleted, object: nil)
        NSApp.keyWindow?.close()
    }
}

// MARK: - Steps

private struct WelcomeStep: View {
    var body: some View {
        StepLayout {
            Image(nsImage: AppMetadata.logo)
                .resizable()
                .frame(width: 80, height: 80)

            Text("Ch√†o m·ª´ng ƒë·∫øn v·ªõi \(AppMetadata.name)")
                .font(.title2.bold())

            Text(AppMetadata.tagline)
                .foregroundStyle(.secondary)
        }
    }
}

private struct PermissionStep: View {
    var body: some View {
        StepLayout {
            Image(systemName: "hand.raised.fill")
                .font(.system(size: 40))
                .foregroundStyle(.orange)

            Text("C·∫•p quy·ªÅn Accessibility")
                .font(.title2.bold())

            Text("B·∫≠t \(AppMetadata.name) trong System Settings ƒë·ªÉ g√µ ti·∫øng Vi·ªát.")
                .foregroundStyle(.secondary)
                .multilineTextAlignment(.center)

            VStack(alignment: .leading, spacing: 8) {
                Label("M·ªü Privacy & Security ‚Üí Accessibility", systemImage: "1.circle.fill")
                Label("B·∫≠t c√¥ng t·∫Øc b√™n c·∫°nh \(AppMetadata.name)", systemImage: "2.circle.fill")
            }
            .font(.callout)
            .foregroundStyle(.secondary)
            .padding(.top, 4)
        }
    }
}

private struct ReadyStep: View {
    var body: some View {
        StepLayout {
            Image(systemName: "checkmark.shield.fill")
                .font(.system(size: 40))
                .foregroundStyle(.green)

            Text("ƒê√£ c·∫•p quy·ªÅn")
                .font(.title2.bold())

            Text("Nh·∫•n \"Kh·ªüi ƒë·ªông l·∫°i\" ƒë·ªÉ √°p d·ª•ng.")
                .foregroundStyle(.secondary)
        }
    }
}

private struct SuccessStep: View {
    var body: some View {
        StepLayout {
            Image(systemName: "checkmark.circle.fill")
                .font(.system(size: 48))
                .foregroundStyle(.green)

            Text("S·∫µn s√†ng ho·∫°t ƒë·ªông")
                .font(.title2.bold())

            Text("\(AppMetadata.name) ƒë√£ ƒë∆∞·ª£c c·∫•p quy·ªÅn th√†nh c√¥ng.")
                .foregroundStyle(.secondary)
        }
    }
}

private struct SetupStep: View {
    @Binding var selectedMode: InputMode

    var body: some View {
        StepLayout {
            Image(systemName: "keyboard")
                .font(.system(size: 40))
                .foregroundStyle(.blue)

            Text("Ch·ªçn ki·ªÉu g√µ")
                .font(.title2.bold())

            Text("C√≥ th·ªÉ thay ƒë·ªïi sau trong menu.")
                .foregroundStyle(.secondary)

            VStack(spacing: 8) {
                ForEach(InputMode.allCases, id: \.rawValue) { mode in
                    ModeOption(mode: mode, isSelected: selectedMode == mode) {
                        selectedMode = mode
                    }
                }
            }
            .frame(maxWidth: 260)
            .padding(.top, 8)
        }
    }
}

private struct ModeOption: View {
    let mode: InputMode
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                VStack(alignment: .leading, spacing: 2) {
                    Text(mode.name)
                        .font(.headline)
                    Text(mode.description)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }
                Spacer()
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .font(.system(size: 20))
                    .foregroundStyle(isSelected ? Color.accentColor : Color.secondary.opacity(0.4))
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 10)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(isSelected ? Color.accentColor.opacity(0.1) : Color.secondary.opacity(0.05))
            )
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(isSelected ? Color.accentColor.opacity(0.5) : .clear, lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Components

private struct StepLayout<Content: View>: View {
    @ViewBuilder let content: Content

    var body: some View {
        VStack(spacing: 12) {
            Spacer()
            content
            Spacer()
        }
        .padding(.horizontal, 40)
    }
}

// MARK: - Notification

extension Notification.Name {
    static let onboardingCompleted = Notification.Name("onboardingCompleted")
}
</file>

<file path="platforms/macos/MenuBar.swift">
import Cocoa
import SwiftUI

// MARK: - SwiftUI Toggle Wrapper

class ToggleState: ObservableObject {
    @Published var isOn: Bool
    var onToggle: (() -> Void)?

    init(isOn: Bool) {
        self.isOn = isOn
    }
}

struct ToggleWrapperView: View {
    @ObservedObject var state: ToggleState

    var body: some View {
        Toggle("", isOn: $state.isOn)
            .toggleStyle(.switch)
            .tint(.green)
            .onChange(of: state.isOn) { _ in
                state.onToggle?()
            }
            .labelsHidden()
    }
}

// MARK: - Menu Bar Controller

class MenuBarController {
    private var statusItem: NSStatusItem!
    private var onboardingWindow: NSWindow?
    private var aboutWindow: NSWindow?
    private var updateWindow: NSWindow?
    private var toggleState: ToggleState?

    private var isEnabled = true
    private var currentMethod: InputMode = .telex

    init() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)

        NotificationCenter.default.addObserver(
            self,
            selector: #selector(onboardingDidComplete),
            name: .onboardingCompleted,
            object: nil
        )

        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleToggleVietnamese),
            name: .toggleVietnamese,
            object: nil
        )

        setupMenu()
        updateStatusButton()

        if UserDefaults.standard.bool(forKey: SettingsKey.hasCompletedOnboarding) && AXIsProcessTrusted() {
            loadSettings()
            startEngine()
        } else {
            showOnboarding()
        }
    }

    @objc private func handleToggleVietnamese() {
        isEnabled.toggle()
        UserDefaults.standard.set(isEnabled, forKey: SettingsKey.enabled)
        RustBridge.setEnabled(isEnabled)
        updateStatusButton()
        updateMenu()
    }

    // MARK: - Setup

    private func loadSettings() {
        isEnabled = UserDefaults.standard.object(forKey: SettingsKey.enabled) as? Bool ?? true
        currentMethod = InputMode(rawValue: UserDefaults.standard.integer(forKey: SettingsKey.method)) ?? .telex
    }

    private func startEngine() {
        RustBridge.initialize()
        KeyboardHookManager.shared.start()
        RustBridge.setEnabled(isEnabled)
        RustBridge.setMethod(currentMethod.rawValue)

        // Check for updates in background after a short delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            UpdateManager.shared.checkForUpdatesSilently()
        }
    }

    @objc private func onboardingDidComplete() {
        loadSettings()
        updateStatusButton()
        updateMenu()
        startEngine()
        enableLaunchAtLogin()
    }

    // MARK: - Status Button

    private func updateStatusButton() {
        guard let button = statusItem.button else { return }
        button.title = ""
        button.image = createStatusIcon(text: isEnabled ? "V" : "E")
    }

    private func createStatusIcon(text: String) -> NSImage {
        let width: CGFloat = 22
        let height: CGFloat = 16
        let image = NSImage(size: NSSize(width: width, height: height))

        image.lockFocus()

        // Background tr·∫Øng bo g√≥c nh·∫π
        let rect = NSRect(x: 0, y: 0, width: width, height: height)
        let path = NSBezierPath(roundedRect: rect, xRadius: 3, yRadius: 3)
        NSColor.white.setFill()
        path.fill()

        // Text transparent (d√πng .clear v·ªõi blend mode)
        let font = NSFont.systemFont(ofSize: 13, weight: .bold)
        let attrs: [NSAttributedString.Key: Any] = [
            .font: font,
            .foregroundColor: NSColor.black
        ]
        let textSize = text.size(withAttributes: attrs)
        let textRect = NSRect(
            x: (width - textSize.width) / 2,
            y: (height - textSize.height) / 2,
            width: textSize.width,
            height: textSize.height
        )

        // V·∫Ω text v·ªõi blend mode ƒë·ªÉ t·∫°o transparent
        NSGraphicsContext.current?.compositingOperation = .destinationOut
        text.draw(in: textRect, withAttributes: attrs)

        image.unlockFocus()
        image.isTemplate = false
        return image
    }

    // MARK: - Menu

    private func setupMenu() {
        let menu = NSMenu()

        // Header with toggle
        let header = NSMenuItem()
        header.view = createHeaderView()
        header.tag = 1
        menu.addItem(header)
        menu.addItem(.separator())

        // Input methods
        let telex = NSMenuItem(title: "Telex", action: #selector(selectTelex), keyEquivalent: "1")
        telex.keyEquivalentModifierMask = .command
        telex.target = self
        telex.tag = 10
        menu.addItem(telex)

        let vni = NSMenuItem(title: "VNI", action: #selector(selectVNI), keyEquivalent: "2")
        vni.keyEquivalentModifierMask = .command
        vni.target = self
        vni.tag = 11
        menu.addItem(vni)
        menu.addItem(.separator())

        // About & Help
        let about = NSMenuItem(title: "Gi·ªõi thi·ªáu \(AppMetadata.name)", action: #selector(showAbout), keyEquivalent: "")
        about.target = self
        menu.addItem(about)

        let checkUpdate = NSMenuItem(title: "Ki·ªÉm tra c·∫≠p nh·∫≠t...", action: #selector(checkForUpdates), keyEquivalent: "u")
        checkUpdate.keyEquivalentModifierMask = .command
        checkUpdate.target = self
        menu.addItem(checkUpdate)

        let help = NSMenuItem(title: "G√≥p √Ω & B√°o l·ªói", action: #selector(openHelp), keyEquivalent: "")
        help.target = self
        menu.addItem(help)
        menu.addItem(.separator())

        // Quit
        let quit = NSMenuItem(title: "Tho√°t", action: #selector(NSApp.terminate), keyEquivalent: "q")
        menu.addItem(quit)

        statusItem.menu = menu
        updateMenu()
    }

    private func createHeaderView() -> NSView {
        let view = NSView(frame: NSRect(x: 0, y: 0, width: 220, height: 36))

        // App name
        let name = NSTextField(labelWithString: AppMetadata.name)
        name.font = .systemFont(ofSize: 13, weight: .bold)
        name.frame = NSRect(x: 14, y: 10, width: 120, height: 16)
        view.addSubview(name)

        // Toggle using SwiftUI for custom tint color
        if toggleState == nil {
            toggleState = ToggleState(isOn: isEnabled)
            toggleState?.onToggle = { [weak self] in self?.handleToggle() }
        }
        toggleState?.isOn = isEnabled
        let toggleView = ToggleWrapperView(state: toggleState!)
        let hostingView = NSHostingView(rootView: toggleView)
        hostingView.frame = NSRect(x: 162, y: 4, width: 50, height: 28)
        view.addSubview(hostingView)

        return view
    }

    private func updateMenu() {
        guard let menu = statusItem.menu else { return }
        menu.item(withTag: 1)?.view = createHeaderView()
        menu.item(withTag: 10)?.state = currentMethod == .telex ? .on : .off
        menu.item(withTag: 11)?.state = currentMethod == .vni ? .on : .off
    }

    // MARK: - Actions

    private func handleToggle() {
        isEnabled = toggleState?.isOn ?? !isEnabled
        UserDefaults.standard.set(isEnabled, forKey: SettingsKey.enabled)
        RustBridge.setEnabled(isEnabled)
        updateStatusButton()
        // Update method checkmarks only, toggle animates itself
        guard let menu = statusItem.menu else { return }
        menu.item(withTag: 10)?.state = currentMethod == .telex ? .on : .off
        menu.item(withTag: 11)?.state = currentMethod == .vni ? .on : .off
    }

    @objc private func selectTelex() { setMethod(.telex) }
    @objc private func selectVNI() { setMethod(.vni) }

    private func setMethod(_ mode: InputMode) {
        currentMethod = mode
        UserDefaults.standard.set(mode.rawValue, forKey: SettingsKey.method)
        RustBridge.setMethod(mode.rawValue)
        updateStatusButton()
        updateMenu()
    }

    private func enableLaunchAtLogin() {
        do {
            try LaunchAtLoginManager.shared.enable()
        } catch {
            debugLog("[LaunchAtLogin] Error: \(error)")
        }
    }

    private func showOnboarding() {
        if onboardingWindow == nil {
            let view = OnboardingView()
            let controller = NSHostingController(rootView: view)
            onboardingWindow = NSWindow(contentViewController: controller)
            onboardingWindow?.title = AppMetadata.name
            onboardingWindow?.styleMask = [.titled, .closable]
            onboardingWindow?.setContentSize(controller.view.fittingSize)
            onboardingWindow?.center()
        }
        onboardingWindow?.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }

    @objc private func showAbout() {
        if aboutWindow == nil {
            let controller = NSHostingController(rootView: AboutView())
            let window = NSWindow(contentViewController: controller)
            window.title = "Gi·ªõi thi·ªáu \(AppMetadata.name)"
            window.styleMask = [.titled, .closable]
            window.setContentSize(controller.view.fittingSize)
            window.center()
            window.isReleasedWhenClosed = false
            aboutWindow = window
        }
        NSApp.activate(ignoringOtherApps: true)
        aboutWindow?.makeKeyAndOrderFront(nil)
    }

    @objc private func openHelp() {
        NSWorkspace.shared.open(URL(string: AppMetadata.issuesURL)!)
    }

    @objc private func checkForUpdates() {
        if updateWindow == nil {
            let controller = NSHostingController(rootView: UpdateView())
            let window = NSWindow(contentViewController: controller)
            window.title = "Ki·ªÉm tra c·∫≠p nh·∫≠t"
            window.styleMask = [.titled, .closable]
            window.setContentSize(controller.view.fittingSize)
            window.center()
            window.isReleasedWhenClosed = false
            updateWindow = window
        }
        NSApp.activate(ignoringOtherApps: true)
        updateWindow?.makeKeyAndOrderFront(nil)

        // Trigger update check when window opens
        UpdateManager.shared.checkForUpdatesManually()
    }
}
</file>

</files>
